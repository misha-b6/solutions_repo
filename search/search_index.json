{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Step 1: Understanding Projectile Motion Projectile motion follows two independent components: 1. Horizontal Motion : Moves at constant velocity. 2. Vertical Motion : Affected by gravity. Ignoring air resistance, we assume: - Initial velocity: \\(v_0\\) - Launch angle: \\(\\theta\\) - Gravity: \\(g\\) The goal is to find how the range depends on \\(\\theta\\) . Step 2: Deriving the Equations of Motion Using kinematic equations: Horizontal Motion: Initial horizontal velocity: $$ v_{x0} = v_0\\cos(\\theta) $$ Horizontal displacement at time \\(t\\) : $$ x(t) = v_0\\cos(\\theta) t $$ Vertical Motion: Initial vertical velocity: $$ v_{y0} = v_0\\sin(\\theta) $$ Vertical displacement at time \\(t\\) : $$ y(t) = v_0\\sin(\\theta) t - \\frac{1}{2}gt^2 $$ The projectile reaches the ground when \\(y = 0\\) . Solving for \\(t\\) : \\[ t_f = \\frac{2v_0\\sin(\\theta)}{g}. \\] Step 3: Calculating the Range The range is the horizontal distance traveled before landing: \\[ R = x(t_f) = v_0\\cos(\\theta) t_f. \\] Substituting \\(t_f\\) : \\[ R = v_0\\cos(\\theta) \\times \\frac{2v_0\\sin(\\theta)}{g}. \\] Using \\(\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)\\) : \\[ R = \\frac{v_0^2\\sin(2\\theta)}{g}. \\] Step 4: Analyzing the Range Equation Effect of Angle : Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , i.e., \\(\\theta = 45^\\circ\\) . The function is symmetric about \\(45^\\circ\\) , meaning angles like \\(30^\\circ\\) and \\(60^\\circ\\) yield the same range. Effect of Initial Velocity : Range increases quadratically with \\(v_0\\) . Effect of Gravity : Increasing \\(g\\) decreases range, as expected in stronger gravitational fields. import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees radians = np.radians(angles) # Convert to radians # Compute range ranges = (v0**2 * np.sin(2 * radians)) / g # Plot results plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=r\"$R = \\frac{v_0^2\\sin(2\\theta)}{g}$\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show() Step 5: Practical Applications Sports : Finding the best angle for throwing a javelin or soccer ball. Engineering : Estimating landing zones for projectiles. Astronomy : Calculating trajectories of objects in space. Step 6: Model Limitations No Air Resistance : Real-world projectiles experience drag, which shortens the range. Different Heights : If launched from or landing on different heights, calculations must be adjusted. Wind Effects : Wind can increase or decrease range unpredictably. For greater accuracy, numerical methods (e.g., solving differential equations with drag) are required.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-understanding-projectile-motion","text":"Projectile motion follows two independent components: 1. Horizontal Motion : Moves at constant velocity. 2. Vertical Motion : Affected by gravity. Ignoring air resistance, we assume: - Initial velocity: \\(v_0\\) - Launch angle: \\(\\theta\\) - Gravity: \\(g\\) The goal is to find how the range depends on \\(\\theta\\) .","title":"Step 1: Understanding Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-deriving-the-equations-of-motion","text":"Using kinematic equations:","title":"Step 2: Deriving the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Initial horizontal velocity: $$ v_{x0} = v_0\\cos(\\theta) $$ Horizontal displacement at time \\(t\\) : $$ x(t) = v_0\\cos(\\theta) t $$","title":"Horizontal Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Initial vertical velocity: $$ v_{y0} = v_0\\sin(\\theta) $$ Vertical displacement at time \\(t\\) : $$ y(t) = v_0\\sin(\\theta) t - \\frac{1}{2}gt^2 $$ The projectile reaches the ground when \\(y = 0\\) . Solving for \\(t\\) : \\[ t_f = \\frac{2v_0\\sin(\\theta)}{g}. \\]","title":"Vertical Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-calculating-the-range","text":"The range is the horizontal distance traveled before landing: \\[ R = x(t_f) = v_0\\cos(\\theta) t_f. \\] Substituting \\(t_f\\) : \\[ R = v_0\\cos(\\theta) \\times \\frac{2v_0\\sin(\\theta)}{g}. \\] Using \\(\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)\\) : \\[ R = \\frac{v_0^2\\sin(2\\theta)}{g}. \\]","title":"Step 3: Calculating the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-analyzing-the-range-equation","text":"Effect of Angle : Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , i.e., \\(\\theta = 45^\\circ\\) . The function is symmetric about \\(45^\\circ\\) , meaning angles like \\(30^\\circ\\) and \\(60^\\circ\\) yield the same range. Effect of Initial Velocity : Range increases quadratically with \\(v_0\\) . Effect of Gravity : Increasing \\(g\\) decreases range, as expected in stronger gravitational fields. import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees radians = np.radians(angles) # Convert to radians # Compute range ranges = (v0**2 * np.sin(2 * radians)) / g # Plot results plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=r\"$R = \\frac{v_0^2\\sin(2\\theta)}{g}$\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show()","title":"Step 4: Analyzing the Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-5-practical-applications","text":"Sports : Finding the best angle for throwing a javelin or soccer ball. Engineering : Estimating landing zones for projectiles. Astronomy : Calculating trajectories of objects in space.","title":"Step 5: Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-6-model-limitations","text":"No Air Resistance : Real-world projectiles experience drag, which shortens the range. Different Heights : If launched from or landing on different heights, calculations must be adjusted. Wind Effects : Wind can increase or decrease range unpredictably. For greater accuracy, numerical methods (e.g., solving differential equations with drag) are required.","title":"Step 6: Model Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Step 1: Theoretical Foundation We consider the equation for a forced damped pendulum: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t)\\] This includes damping \\(b\\) , gravity \\(g\\) , length \\(L\\) , and periodic forcing \\(A\\cos(\\omega t)\\) . To solve it numerically, we rewrite it as a system of first-order ODEs. Step 1.1: Approximate Solution for Small-Angle Oscillations To simplify the analysis, we consider the small-angle approximation: \\[\\sin\\theta \\approx \\theta\\] Substituting this into the original equation gives a linear second-order nonhomogeneous differential equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\] This is a standard linear ODE with constant coefficients and a cosine forcing term. The general solution consists of two parts: 1. Homogeneous Solution Solve the homogeneous equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = 0\\] Assume a solution of the form \\(\\theta_h(t) = e^{\\lambda t}\\) : Then: \\[\\lambda^2 + b\\lambda + \\frac{g}{L} = 0\\] Solve the characteristic equation: If the discriminant \\(D = b^2 - 4\\frac{g}{L} > 0\\) : overdamped If \\(D = 0\\) : critically damped If \\(D < 0\\) : underdamped (oscillatory), which gives: \\[\\theta_h(t) = e^{-\\frac{b}{2}t}(C_1\\cos(\\omega_0 t) + C_2\\sin(\\omega_0 t))\\] where: \\[\\omega_0 = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}}\\] 2. Particular Solution Assume a solution of the form: \\[\\theta_p(t) = B\\cos(\\omega t) + C\\sin(\\omega t)\\] Plug into the ODE and match coefficients. After simplification: The steady-state solution is: \\[\\theta_p(t) = \\frac{A}{\\sqrt{(\\frac{g}{L} - \\omega^2)^2 + (b\\omega)^2}} \\cos(\\omega t - \\delta)\\] where the phase shift \\(\\delta\\) is given by: \\[\\tan(\\delta) = \\frac{b\\omega}{\\frac{g}{L} - \\omega^2}\\] Final Approximate Solution: Combining both parts: \\[\\theta(t) = \\theta_h(t) + \\theta_p(t)\\] In the long term, the homogeneous part decays due to damping, and the system reaches a steady-state periodic solution with amplitude and phase depending on \\(A\\) , \\(b\\) , \\(\\omega\\) , and \\(\\frac{g}{L}\\) . This approximation is useful for analyzing resonance and predicting the system\u2019s response under small displacements. Step 2: System of Equations. Analysis of Dynamics: Let: \\(x_1 = \\theta\\) \\(x_2 = \\frac{d\\theta}{dt}\\) Then: \\[\\frac{dx_1}{dt} = x_2$$ $$\\frac{dx_2}{dt} = -b x_2 - \\frac{g}{L} \\sin(x_1) + A \\cos(\\omega t)\\] Step 3: Angle and Phase Space Simulation The forced damped pendulum model is relevant to various engineering and physical systems. Some real-world examples include: Energy harvesting systems , where mechanical vibrations are converted into electrical energy using oscillating parts. Suspension bridges , where damping and periodic forces play a role in stabilizing the structure under wind or traffic loads. Oscillating electrical circuits (e.g., RLC circuits), which behave analogously to mechanical oscillators with damping and driving forces. Biomechanics , such as modeling the motion of limbs or joints under muscle activation and external load. Step 4: Poincar\u00e9 Section Python Code: Combined Pendulum Plots (\u03b8(t), \u03c9(t), Phase Portrait) python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 L = 1.0 b = 0.3 A = 1.2 w = 2.0 # Initial conditions theta0 = 0.2 omega0 = 0.0 y0 = [theta0, omega0] # Time setup t_start = 0 t_end = 20 num_points = 5000 t_vals = np.linspace(t_start, t_end, num_points) # Define the system def pendulum(t, y): theta = y[0] omega = y[1] dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(w * t) return [dtheta_dt, domega_dt] # Solve the system sol = solve_ivp(pendulum, [t_start, t_end], y0, t_eval=t_vals) theta = sol.y[0] omega = sol.y[1] time = sol.t # Plot results in subplots fig, axs = plt.subplots(2, 2, figsize=(12, 8)) fig.suptitle('Forced Damped Pendulum Simulation', fontsize=16) # \u03b8(t) axs[0, 0].plot(time, theta, label='\u03b8(t)', color='royalblue') axs[0, 0].set_title('Angle vs Time') axs[0, 0].set_xlabel('Time (s)') axs[0, 0].set_ylabel('Angle \u03b8 (rad)') axs[0, 0].grid(True) axs[0, 0].legend() # \u03c9(t) axs[0, 1].plot(time, omega, label='d\u03b8/dt(t)', color='orange') axs[0, 1].set_title('Angular Velocity vs Time') axs[0, 1].set_xlabel('Time (s)') axs[0, 1].set_ylabel('Angular Velocity (rad/s)') axs[0, 1].grid(True) axs[0, 1].legend() # Phase portrait: \u03c9 vs \u03b8 axs[1, 0].plot(theta, omega, label='Phase Portrait', color='steelblue') axs[1, 0].set_title('Phase Portrait') axs[1, 0].set_xlabel('Angle \u03b8 (rad)') axs[1, 0].set_ylabel('Angular Velocity d\u03b8/dt (rad/s)') axs[1, 0].grid(True) axs[1, 0].legend() # Hide unused subplot axs[1, 1].axis('off') plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.show() Explanation of the Code Parameters : The script defines physical parameters including \\(g\\) (gravity), \\(L\\) (length), \\(b\\) (damping), \\(A\\) (amplitude of forcing), and \\(\\omega\\) (driving frequency). ODE System : The nonlinear second-order differential equation is rewritten as a system of first-order ODEs: $$ \\frac{d\\theta}{dt} = \\omega, \\quad \\frac{d\\omega}{dt} = -b\\omega - \\frac{g}{L} \\sin\\theta + A \\cos(\\omega t) $$ Numerical Solution : The system is solved using solve_ivp from scipy.integrate , which implements a Runge-Kutta method with adaptive time stepping. Plots : \\(\\theta(t)\\) \u2014 Angle over time \\(\\dot{\\theta}(t)\\) \u2014 Angular velocity over time Phase portrait \u2014 \\(\\dot{\\theta}\\) vs. \\(\\theta\\)","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-1-theoretical-foundation","text":"We consider the equation for a forced damped pendulum: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t)\\] This includes damping \\(b\\) , gravity \\(g\\) , length \\(L\\) , and periodic forcing \\(A\\cos(\\omega t)\\) . To solve it numerically, we rewrite it as a system of first-order ODEs.","title":"Step 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-11-approximate-solution-for-small-angle-oscillations","text":"To simplify the analysis, we consider the small-angle approximation: \\[\\sin\\theta \\approx \\theta\\] Substituting this into the original equation gives a linear second-order nonhomogeneous differential equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\] This is a standard linear ODE with constant coefficients and a cosine forcing term. The general solution consists of two parts:","title":"Step 1.1: Approximate Solution for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-homogeneous-solution","text":"Solve the homogeneous equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = 0\\] Assume a solution of the form \\(\\theta_h(t) = e^{\\lambda t}\\) : Then: \\[\\lambda^2 + b\\lambda + \\frac{g}{L} = 0\\] Solve the characteristic equation: If the discriminant \\(D = b^2 - 4\\frac{g}{L} > 0\\) : overdamped If \\(D = 0\\) : critically damped If \\(D < 0\\) : underdamped (oscillatory), which gives: \\[\\theta_h(t) = e^{-\\frac{b}{2}t}(C_1\\cos(\\omega_0 t) + C_2\\sin(\\omega_0 t))\\] where: \\[\\omega_0 = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}}\\]","title":"1. Homogeneous Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-particular-solution","text":"Assume a solution of the form: \\[\\theta_p(t) = B\\cos(\\omega t) + C\\sin(\\omega t)\\] Plug into the ODE and match coefficients. After simplification: The steady-state solution is: \\[\\theta_p(t) = \\frac{A}{\\sqrt{(\\frac{g}{L} - \\omega^2)^2 + (b\\omega)^2}} \\cos(\\omega t - \\delta)\\] where the phase shift \\(\\delta\\) is given by: \\[\\tan(\\delta) = \\frac{b\\omega}{\\frac{g}{L} - \\omega^2}\\]","title":"2. Particular Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#final-approximate-solution","text":"Combining both parts: \\[\\theta(t) = \\theta_h(t) + \\theta_p(t)\\] In the long term, the homogeneous part decays due to damping, and the system reaches a steady-state periodic solution with amplitude and phase depending on \\(A\\) , \\(b\\) , \\(\\omega\\) , and \\(\\frac{g}{L}\\) . This approximation is useful for analyzing resonance and predicting the system\u2019s response under small displacements.","title":"Final Approximate Solution:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-2-system-of-equations-analysis-of-dynamics","text":"Let: \\(x_1 = \\theta\\) \\(x_2 = \\frac{d\\theta}{dt}\\) Then: \\[\\frac{dx_1}{dt} = x_2$$ $$\\frac{dx_2}{dt} = -b x_2 - \\frac{g}{L} \\sin(x_1) + A \\cos(\\omega t)\\]","title":"Step 2: System of Equations. Analysis of Dynamics:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-3-angle-and-phase-space-simulation","text":"The forced damped pendulum model is relevant to various engineering and physical systems. Some real-world examples include: Energy harvesting systems , where mechanical vibrations are converted into electrical energy using oscillating parts. Suspension bridges , where damping and periodic forces play a role in stabilizing the structure under wind or traffic loads. Oscillating electrical circuits (e.g., RLC circuits), which behave analogously to mechanical oscillators with damping and driving forces. Biomechanics , such as modeling the motion of limbs or joints under muscle activation and external load.","title":"Step 3: Angle and Phase Space Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-4-poincare-section","text":"Python Code: Combined Pendulum Plots (\u03b8(t), \u03c9(t), Phase Portrait) python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 L = 1.0 b = 0.3 A = 1.2 w = 2.0 # Initial conditions theta0 = 0.2 omega0 = 0.0 y0 = [theta0, omega0] # Time setup t_start = 0 t_end = 20 num_points = 5000 t_vals = np.linspace(t_start, t_end, num_points) # Define the system def pendulum(t, y): theta = y[0] omega = y[1] dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(w * t) return [dtheta_dt, domega_dt] # Solve the system sol = solve_ivp(pendulum, [t_start, t_end], y0, t_eval=t_vals) theta = sol.y[0] omega = sol.y[1] time = sol.t # Plot results in subplots fig, axs = plt.subplots(2, 2, figsize=(12, 8)) fig.suptitle('Forced Damped Pendulum Simulation', fontsize=16) # \u03b8(t) axs[0, 0].plot(time, theta, label='\u03b8(t)', color='royalblue') axs[0, 0].set_title('Angle vs Time') axs[0, 0].set_xlabel('Time (s)') axs[0, 0].set_ylabel('Angle \u03b8 (rad)') axs[0, 0].grid(True) axs[0, 0].legend() # \u03c9(t) axs[0, 1].plot(time, omega, label='d\u03b8/dt(t)', color='orange') axs[0, 1].set_title('Angular Velocity vs Time') axs[0, 1].set_xlabel('Time (s)') axs[0, 1].set_ylabel('Angular Velocity (rad/s)') axs[0, 1].grid(True) axs[0, 1].legend() # Phase portrait: \u03c9 vs \u03b8 axs[1, 0].plot(theta, omega, label='Phase Portrait', color='steelblue') axs[1, 0].set_title('Phase Portrait') axs[1, 0].set_xlabel('Angle \u03b8 (rad)') axs[1, 0].set_ylabel('Angular Velocity d\u03b8/dt (rad/s)') axs[1, 0].grid(True) axs[1, 0].legend() # Hide unused subplot axs[1, 1].axis('off') plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.show()","title":"Step 4: Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation-of-the-code","text":"Parameters : The script defines physical parameters including \\(g\\) (gravity), \\(L\\) (length), \\(b\\) (damping), \\(A\\) (amplitude of forcing), and \\(\\omega\\) (driving frequency). ODE System : The nonlinear second-order differential equation is rewritten as a system of first-order ODEs: $$ \\frac{d\\theta}{dt} = \\omega, \\quad \\frac{d\\omega}{dt} = -b\\omega - \\frac{g}{L} \\sin\\theta + A \\cos(\\omega t) $$ Numerical Solution : The system is solved using solve_ivp from scipy.integrate , which implements a Runge-Kutta method with adaptive time stepping. Plots : \\(\\theta(t)\\) \u2014 Angle over time \\(\\dot{\\theta}(t)\\) \u2014 Angular velocity over time Phase portrait \u2014 \\(\\dot{\\theta}\\) vs. \\(\\theta\\)","title":"Explanation of the Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Step 1: Deriving Kepler's Third Law from Newtonian Mechanics Let us consider a body of mass \\(m\\) in a circular orbit of radius \\(r\\) around a much larger mass \\(M\\) (e.g., a planet orbiting the Sun). Newton\u2019s Law of Gravitation provides the gravitational force between them: \\[F_g = \\frac{G M m}{r^2}\\] The required centripetal force to maintain a circular orbit is: \\[F_c = m \\frac{v^2}{r}\\] Equating the two forces: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r}\\] Canceling \\(m\\) and simplifying: \\[v^2 = \\frac{G M}{r}\\] The orbital speed \\(v\\) is related to the orbital period \\(T\\) by: \\[v = \\frac{2\\pi r}{T}\\] Substitute into the previous equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r}\\] Now solve for \\(T^2\\) : \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r}\\] Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : \\[T^2 = \\frac{4\\pi^2}{G M} r^3\\] This is Kepler\u2019s Third Law , showing that: \\[T^2 \\propto r^3\\] The constant of proportionality depends only on the central mass \\(M\\) and physical constant \\(G\\) : \\[\\frac{T^2}{r^3} = \\frac{4\\pi^2}{G M}\\] Step 2: Implications for Planetary Motions Kepler\u2019s Third Law has deep implications for understanding planetary systems: Uniformity Across Planets : For planets orbiting the same body (like the Sun), the ratio \\(T^2/r^3\\) is constant. This means that we can compare orbits across the solar system using only period and radius. Example : If one planet is 2 times farther from the Sun than another, its period will be: \\[T = T_0 \\cdot \\left(\\frac{2r_0}{r_0}\\right)^{3/2} = T_0 \\cdot 2^{3/2} \\approx 2.828 \\cdot T_0\\] Role of Mass : The mass of the orbiting object \\(m\\) cancels in the derivation. So small satellites and large moons follow the same law, depending only on the central mass \\(M\\) . Applications : Calculating planetary distances Estimating stellar and planetary masses Predicting satellite orbits Step 3: Real-World Example \u2013 The Moon Let\u2019s use Kepler\u2019s law to estimate Earth\u2019s mass from the Moon\u2019s orbit: Orbital radius of Moon: \\(r = 3.84 \\times 10^8\\) m Period: \\(T = 27.32\\) days = \\(2.36 \\times 10^6\\) s Rearranging the law: \\[M = \\frac{4\\pi^2 r^3}{G T^2}\\] Plugging in values: \\[M = \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} (2.36 \\times 10^6)^2}\\] This yields approximately \\(M \\approx 5.97 \\times 10^{24}\\) kg \u2014 a very accurate estimate of Earth's mass. This confirms both the validity and the precision of Kepler\u2019s Third Law. Step 4: Python Simulation \u2013 Visualizing \\(T^2 \\propto r^3\\) We can simulate various orbital radii and plot \\(T^2\\) vs \\(r^3\\) to confirm the linear relationship: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Orbital radii (m) radii = np.linspace(7e6, 4.2e7, 100) # from 7000 km to 42,000 km periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # T = 2\u03c0\u221a(r^3/GM) # Plotting T^2 vs r^3 r3 = radii**3 T2 = periods**2 plt.figure(figsize=(8, 6)) plt.plot(r3, T2, color='navy') plt.xlabel('$r^3$ (m$^3$)') plt.ylabel('$T^2$ (s$^2$)') plt.title('Kepler\\'s Third Law: $T^2$ vs $r^3$') plt.grid(True) plt.tight_layout() plt.show() Step 6: Elliptical Orbits and Generalization For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] The law still holds for all planets and moons with elliptical paths, as long as \\(a\\) is used instead of \\(r\\) . Summary We derived and confirmed Kepler\u2019s Third Law for circular orbits. The law connects period and radius via gravity. Simulations and plots verify that \\(T^2 \\propto r^3\\) . Real-world systems (like the Moon or satellites) follow this same law.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-deriving-keplers-third-law-from-newtonian-mechanics","text":"Let us consider a body of mass \\(m\\) in a circular orbit of radius \\(r\\) around a much larger mass \\(M\\) (e.g., a planet orbiting the Sun). Newton\u2019s Law of Gravitation provides the gravitational force between them: \\[F_g = \\frac{G M m}{r^2}\\] The required centripetal force to maintain a circular orbit is: \\[F_c = m \\frac{v^2}{r}\\] Equating the two forces: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r}\\] Canceling \\(m\\) and simplifying: \\[v^2 = \\frac{G M}{r}\\] The orbital speed \\(v\\) is related to the orbital period \\(T\\) by: \\[v = \\frac{2\\pi r}{T}\\] Substitute into the previous equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r}\\] Now solve for \\(T^2\\) : \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r}\\] Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : \\[T^2 = \\frac{4\\pi^2}{G M} r^3\\] This is Kepler\u2019s Third Law , showing that: \\[T^2 \\propto r^3\\] The constant of proportionality depends only on the central mass \\(M\\) and physical constant \\(G\\) : \\[\\frac{T^2}{r^3} = \\frac{4\\pi^2}{G M}\\]","title":"Step 1: Deriving Kepler's Third Law from Newtonian Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-implications-for-planetary-motions","text":"Kepler\u2019s Third Law has deep implications for understanding planetary systems: Uniformity Across Planets : For planets orbiting the same body (like the Sun), the ratio \\(T^2/r^3\\) is constant. This means that we can compare orbits across the solar system using only period and radius. Example : If one planet is 2 times farther from the Sun than another, its period will be: \\[T = T_0 \\cdot \\left(\\frac{2r_0}{r_0}\\right)^{3/2} = T_0 \\cdot 2^{3/2} \\approx 2.828 \\cdot T_0\\] Role of Mass : The mass of the orbiting object \\(m\\) cancels in the derivation. So small satellites and large moons follow the same law, depending only on the central mass \\(M\\) . Applications : Calculating planetary distances Estimating stellar and planetary masses Predicting satellite orbits","title":"Step 2: Implications for Planetary Motions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-real-world-example-the-moon","text":"Let\u2019s use Kepler\u2019s law to estimate Earth\u2019s mass from the Moon\u2019s orbit: Orbital radius of Moon: \\(r = 3.84 \\times 10^8\\) m Period: \\(T = 27.32\\) days = \\(2.36 \\times 10^6\\) s Rearranging the law: \\[M = \\frac{4\\pi^2 r^3}{G T^2}\\] Plugging in values: \\[M = \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} (2.36 \\times 10^6)^2}\\] This yields approximately \\(M \\approx 5.97 \\times 10^{24}\\) kg \u2014 a very accurate estimate of Earth's mass. This confirms both the validity and the precision of Kepler\u2019s Third Law.","title":"Step 3: Real-World Example \u2013 The Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-4-python-simulation-visualizing-t2-propto-r3","text":"We can simulate various orbital radii and plot \\(T^2\\) vs \\(r^3\\) to confirm the linear relationship: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Orbital radii (m) radii = np.linspace(7e6, 4.2e7, 100) # from 7000 km to 42,000 km periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # T = 2\u03c0\u221a(r^3/GM) # Plotting T^2 vs r^3 r3 = radii**3 T2 = periods**2 plt.figure(figsize=(8, 6)) plt.plot(r3, T2, color='navy') plt.xlabel('$r^3$ (m$^3$)') plt.ylabel('$T^2$ (s$^2$)') plt.title('Kepler\\'s Third Law: $T^2$ vs $r^3$') plt.grid(True) plt.tight_layout() plt.show()","title":"Step 4: Python Simulation \u2013 Visualizing \\(T^2 \\propto r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-6-elliptical-orbits-and-generalization","text":"For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] The law still holds for all planets and moons with elliptical paths, as long as \\(a\\) is used instead of \\(r\\) .","title":"Step 6: Elliptical Orbits and Generalization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived and confirmed Kepler\u2019s Third Law for circular orbits. The law connects period and radius via gravity. Simulations and plots verify that \\(T^2 \\propto r^3\\) . Real-world systems (like the Moon or satellites) follow this same law.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Step 1: Define the First, Second, and Third Cosmic Velocities with Physical Meaning First Cosmic Velocity (Orbital Velocity) : This is the minimum speed required for an object to stay in a stable circular orbit near the surface of a celestial body. It occurs when the gravitational pull provides the exact centripetal force necessary to maintain that orbit: \\( \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) \\) Second Cosmic Velocity (Escape Velocity) : The second cosmic velocity represents the threshold speed to break free from a body's gravitational field entirely. It's derived from the conservation of energy, ensuring that an object's total mechanical energy reaches zero at an infinite distance: \\( \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) \\) Third Cosmic Velocity (Interstellar Escape Velocity) : To exit an entire star system (like the Solar System), an object must overcome not just Earth's gravity, but also the gravitational influence of the Sun. This velocity is more complex, as it involves both escape from the planet and additional speed to escape from heliocentric orbit. Step 2: Theoretical Derivation and Equations 2.1 First Cosmic Velocity: Set gravitational force equal to centripetal force: \\[\\frac{G M m}{R^2} = m \\frac{v^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{G M}{R}}\\] 2.2 Second Cosmic Velocity: Use energy conservation principle: \\[\\frac{1}{2}mv_2^2 = \\frac{G M m}{R} \\Rightarrow v_2 = \\sqrt{\\frac{2 G M}{R}}\\] 2.3 Third Cosmic Velocity \u2013 Escape from the Sun's Gravity The third cosmic velocity is defined as the speed required to escape the Sun's gravitational field starting from Earth\u2019s orbit. Unlike the second velocity, it considers the object already in motion due to Earth's orbital speed. We define: - \\(M_{\\text{Sun}}\\) : mass of the Sun - \\(r_{\\text{Earth-Sun}}\\) : average distance between the Earth and Sun (\u2248 1 AU) Escape Velocity from Sun at Earth's Orbit : \\[v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Earth's Orbital Speed Around the Sun : \\[v_{\\text{Earth}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Third Cosmic Velocity : To break free from the Solar System, the spacecraft must gain enough speed beyond what Earth already provides: \\[v_3 = v_{\\text{esc,Sun}} - v_{\\text{Earth}}\\] Substituting the expressions: \\[v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Factoring out the common term: \\[v_3 = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} (\\sqrt{2} - 1)\\] This shows that the third cosmic velocity is a fraction \\((\\sqrt{2} - 1 \\approx 0.414)\\) of the Sun\u2019s escape velocity at Earth's orbital distance. This simplification is useful for approximating interstellar mission speeds without requiring complex simulations. Step 3: Python Code to Compute and Plot the Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 # Planetary data: name, radius (m), mass (kg) bodies = { 'Earth': {'R': 6.371e6, 'M': 5.972e24}, 'Mars': {'R': 3.390e6, 'M': 6.417e23}, 'Jupiter': {'R': 6.9911e7, 'M': 1.898e27} } # Prepare results names = [] v1 = [] # Orbital velocity v2 = [] # Escape velocity for body, data in bodies.items(): R = data['R'] M = data['M'] names.append(body) v1.append(np.sqrt(G * M / R)) v2.append(np.sqrt(2 * G * M / R)) # Plotting x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1, width, label='First Cosmic Velocity $v_1$', color='skyblue') plt.bar(x + width/2, v2, width, label='Second Cosmic Velocity $v_2$', color='orange') plt.xticks(x, names) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Celestial Bodies') plt.legend() plt.grid(axis='y') plt.tight_layout() plt.show() 3. Applications in Space Exploration \\(v_1\\) \u2013 Used to place satellites into low Earth orbit (LEO), GPS, and communication satellites. \\(v_2\\) \u2013 Required for missions to the Moon, Mars, and beyond. \\(v_3\\) \u2013 Required to leave the Solar System; achieved by spacecraft like Voyager 1 and 2. First Cosmic Velocity : Essential for satellite missions. Near Earth\u2019s surface, \\(v_1 \\approx 7.9\\) km/s, but satellites in LEO (e.g., at 400 km altitude) orbit at slightly lower speeds (around 7.6 km/s). This velocity is targeted during launches like those delivering payloads to the ISS. Second Cosmic Velocity : Required for planetary escape. For Earth, \\(v_2 \\approx 11.2\\) km/s. Spacecraft such as those used in the Apollo missions had to exceed this threshold to reach the Moon. On Jupiter, escape velocity reaches 59.5 km/s, demanding enormous propulsion capacity (e.g., Juno mission). Third Cosmic Velocity : Enables interstellar escape. For Earth, \\(v_3 \\approx 16.7\\) km/s relative to the heliocentric frame. Voyager 1 gained this velocity through gravity assists and now travels ~17 km/s away from the Sun. These values influence fuel budgets, trajectory design, and feasibility of interstellar probes. Summary Derived and computed \\(v_1\\) , \\(v_2\\) , and discussed \\(v_3\\) Applied to Earth, Mars, and Jupiter Visualized their significance for space missions and satellite deployment","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-1-define-the-first-second-and-third-cosmic-velocities-with-physical-meaning","text":"First Cosmic Velocity (Orbital Velocity) : This is the minimum speed required for an object to stay in a stable circular orbit near the surface of a celestial body. It occurs when the gravitational pull provides the exact centripetal force necessary to maintain that orbit: \\( \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) \\) Second Cosmic Velocity (Escape Velocity) : The second cosmic velocity represents the threshold speed to break free from a body's gravitational field entirely. It's derived from the conservation of energy, ensuring that an object's total mechanical energy reaches zero at an infinite distance: \\( \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) \\) Third Cosmic Velocity (Interstellar Escape Velocity) : To exit an entire star system (like the Solar System), an object must overcome not just Earth's gravity, but also the gravitational influence of the Sun. This velocity is more complex, as it involves both escape from the planet and additional speed to escape from heliocentric orbit.","title":"Step 1: Define the First, Second, and Third Cosmic Velocities with Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-2-theoretical-derivation-and-equations","text":"","title":"Step 2: Theoretical Derivation and Equations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-first-cosmic-velocity","text":"Set gravitational force equal to centripetal force: \\[\\frac{G M m}{R^2} = m \\frac{v^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{G M}{R}}\\]","title":"2.1 First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-second-cosmic-velocity","text":"Use energy conservation principle: \\[\\frac{1}{2}mv_2^2 = \\frac{G M m}{R} \\Rightarrow v_2 = \\sqrt{\\frac{2 G M}{R}}\\]","title":"2.2 Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity-escape-from-the-suns-gravity","text":"The third cosmic velocity is defined as the speed required to escape the Sun's gravitational field starting from Earth\u2019s orbit. Unlike the second velocity, it considers the object already in motion due to Earth's orbital speed. We define: - \\(M_{\\text{Sun}}\\) : mass of the Sun - \\(r_{\\text{Earth-Sun}}\\) : average distance between the Earth and Sun (\u2248 1 AU) Escape Velocity from Sun at Earth's Orbit : \\[v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Earth's Orbital Speed Around the Sun : \\[v_{\\text{Earth}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Third Cosmic Velocity : To break free from the Solar System, the spacecraft must gain enough speed beyond what Earth already provides: \\[v_3 = v_{\\text{esc,Sun}} - v_{\\text{Earth}}\\] Substituting the expressions: \\[v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Factoring out the common term: \\[v_3 = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} (\\sqrt{2} - 1)\\] This shows that the third cosmic velocity is a fraction \\((\\sqrt{2} - 1 \\approx 0.414)\\) of the Sun\u2019s escape velocity at Earth's orbital distance. This simplification is useful for approximating interstellar mission speeds without requiring complex simulations.","title":"2.3 Third Cosmic Velocity \u2013 Escape from the Sun's Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-3-python-code-to-compute-and-plot-the-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 # Planetary data: name, radius (m), mass (kg) bodies = { 'Earth': {'R': 6.371e6, 'M': 5.972e24}, 'Mars': {'R': 3.390e6, 'M': 6.417e23}, 'Jupiter': {'R': 6.9911e7, 'M': 1.898e27} } # Prepare results names = [] v1 = [] # Orbital velocity v2 = [] # Escape velocity for body, data in bodies.items(): R = data['R'] M = data['M'] names.append(body) v1.append(np.sqrt(G * M / R)) v2.append(np.sqrt(2 * G * M / R)) # Plotting x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1, width, label='First Cosmic Velocity $v_1$', color='skyblue') plt.bar(x + width/2, v2, width, label='Second Cosmic Velocity $v_2$', color='orange') plt.xticks(x, names) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Celestial Bodies') plt.legend() plt.grid(axis='y') plt.tight_layout() plt.show()","title":"Step 3: Python Code to Compute and Plot the Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-applications-in-space-exploration","text":"\\(v_1\\) \u2013 Used to place satellites into low Earth orbit (LEO), GPS, and communication satellites. \\(v_2\\) \u2013 Required for missions to the Moon, Mars, and beyond. \\(v_3\\) \u2013 Required to leave the Solar System; achieved by spacecraft like Voyager 1 and 2. First Cosmic Velocity : Essential for satellite missions. Near Earth\u2019s surface, \\(v_1 \\approx 7.9\\) km/s, but satellites in LEO (e.g., at 400 km altitude) orbit at slightly lower speeds (around 7.6 km/s). This velocity is targeted during launches like those delivering payloads to the ISS. Second Cosmic Velocity : Required for planetary escape. For Earth, \\(v_2 \\approx 11.2\\) km/s. Spacecraft such as those used in the Apollo missions had to exceed this threshold to reach the Moon. On Jupiter, escape velocity reaches 59.5 km/s, demanding enormous propulsion capacity (e.g., Juno mission). Third Cosmic Velocity : Enables interstellar escape. For Earth, \\(v_3 \\approx 16.7\\) km/s relative to the heliocentric frame. Voyager 1 gained this velocity through gravity assists and now travels ~17 km/s away from the Sun. These values influence fuel budgets, trajectory design, and feasibility of interstellar probes.","title":"3. Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"Derived and computed \\(v_1\\) , \\(v_2\\) , and discussed \\(v_3\\) Applied to Earth, Mars, and Jupiter Visualized their significance for space missions and satellite deployment","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Step 1: Analyze Possible Trajectories When a payload is released from a rocket near Earth, its future motion is determined by its speed, direction, and altitude. Depending on the specific energy \\(\\epsilon\\) of the system, the resulting path can be classified as: Elliptical Trajectory ( \\(\\epsilon < 0\\) ): Bound orbit, repeating paths (circular or oval). Parabolic Trajectory ( \\(\\epsilon = 0\\) ): The minimum speed needed to escape Earth \u2014 marginal case. Hyperbolic Trajectory ( \\(\\epsilon > 0\\) ): Payload escapes Earth with excess kinetic energy. The specific mechanical energy (energy per unit mass) is: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] Where: - \\(v\\) is the speed of the payload, - \\(r\\) is the radial distance from Earth\u2019s center, - \\(G\\) is the gravitational constant, - \\(M\\) is the Earth's mass. The expression comes from combining kinetic and gravitational potential energy: Kinetic energy per unit mass: \\(\\frac{1}{2}v^2\\) Gravitational potential energy per unit mass: \\(-\\frac{GM}{r}\\) Hence: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] This confirms: - \\(\\epsilon < 0\\) : Elliptical orbit (bound) - \\(\\epsilon = 0\\) : Parabolic escape - \\(\\epsilon > 0\\) : Hyperbolic escape Formulas for Orbital Mechanics Escape Velocity The speed required to escape a celestial body's gravity from a distance \\(r\\) : \\[v_{esc} = \\sqrt{\\frac{2GM}{r}}\\] Circular Orbital Velocity The speed needed to maintain a circular orbit at radius \\(r\\) : \\[v_{circ} = \\sqrt{\\frac{GM}{r}}\\] Specific Mechanical Energy The total energy per unit mass (kinetic + potential): \\[E = \\frac{v^2}{2} - \\frac{GM}{r}\\] \\(E < 0\\) : Bound orbit (elliptical) \\(E = 0\\) : Parabolic escape \\(E > 0\\) : Hyperbolic escape Gravitational Force Between Two Masses \\[F = \\frac{G m_1 m_2}{r^2}\\] Orbital Period (Kepler\u2019s Third Law) Applies to circular orbits: \\( \\(T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\) \\) Step 2: Equations of Motion in 2D From Newton\u2019s Law of Gravitation: \\[ \\frac{d^2\\vec{r}}{dt^2} = -\\frac{GM}{r^3}\\vec{r} \\] Let \\(\\vec{r} = (x, y)\\) , then: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{r^3}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{r^3} \\] To solve numerically, define the state vector \\([x, y, v_x, v_y]\\) with: \\[ \\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y $$ $$ \\frac{dv_x}{dt} = -\\frac{GMx}{r^3}, \\quad \\frac{dv_y}{dt} = -\\frac{GMy}{r^3} \\] Step 3: Python Code for Trajectory Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # mass of Earth [kg] R = 6.371e6 # radius of Earth [m] mu = G * M # gravitational parameter [m^3/s^2] # Define system of ODEs def dynamics(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Initial position: 400 km above Earth's surface x0 = R + 400000 # meters y0 = 0 # Initial velocities for different trajectory types v_values = [7300, 11180, 13000] # m/s: elliptical, parabolic, hyperbolic labels = ['Elliptical', 'Parabolic', 'Hyperbolic'] colors = ['blue', 'green', 'red'] plt.figure(figsize=(8, 8)) for v0, label, color in zip(v_values, labels, colors): vx0 = 0 vy0 = v0 state0 = [x0, y0, vx0, vy0] t_span = (0, 8000) t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(dynamics, t_span, state0, t_eval=t_eval, rtol=1e-9) x, y = sol.y[0], sol.y[1] plt.plot(x/1000, y/1000, label=label, color=color) # Earth theta = np.linspace(0, 2*np.pi, 300) plt.plot((R * np.cos(theta))/1000, (R * np.sin(theta))/1000, 'k', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Trajectories of a Payload Released Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Step 4: Interpretation Elliptical : Captured orbit. Occurs when the initial speed is below escape velocity. Parabolic : Boundary case. Object escapes with zero final velocity. Hyperbolic : Object escapes with excess energy. Relevant for deep space missions. These simulations reflect practical use cases in satellite deployment, space debris behavior, and interplanetary travel. Summary Introduced energy-based classification of orbits. Derived motion equations for gravitational acceleration in 2D. Created a realistic simulation tool in Python to explore various escape conditions. Discussed relevance to orbital insertion and mission planning.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-1-analyze-possible-trajectories","text":"When a payload is released from a rocket near Earth, its future motion is determined by its speed, direction, and altitude. Depending on the specific energy \\(\\epsilon\\) of the system, the resulting path can be classified as: Elliptical Trajectory ( \\(\\epsilon < 0\\) ): Bound orbit, repeating paths (circular or oval). Parabolic Trajectory ( \\(\\epsilon = 0\\) ): The minimum speed needed to escape Earth \u2014 marginal case. Hyperbolic Trajectory ( \\(\\epsilon > 0\\) ): Payload escapes Earth with excess kinetic energy. The specific mechanical energy (energy per unit mass) is: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] Where: - \\(v\\) is the speed of the payload, - \\(r\\) is the radial distance from Earth\u2019s center, - \\(G\\) is the gravitational constant, - \\(M\\) is the Earth's mass. The expression comes from combining kinetic and gravitational potential energy: Kinetic energy per unit mass: \\(\\frac{1}{2}v^2\\) Gravitational potential energy per unit mass: \\(-\\frac{GM}{r}\\) Hence: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] This confirms: - \\(\\epsilon < 0\\) : Elliptical orbit (bound) - \\(\\epsilon = 0\\) : Parabolic escape - \\(\\epsilon > 0\\) : Hyperbolic escape","title":"Step 1: Analyze Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#formulas-for-orbital-mechanics","text":"Escape Velocity The speed required to escape a celestial body's gravity from a distance \\(r\\) : \\[v_{esc} = \\sqrt{\\frac{2GM}{r}}\\] Circular Orbital Velocity The speed needed to maintain a circular orbit at radius \\(r\\) : \\[v_{circ} = \\sqrt{\\frac{GM}{r}}\\] Specific Mechanical Energy The total energy per unit mass (kinetic + potential): \\[E = \\frac{v^2}{2} - \\frac{GM}{r}\\] \\(E < 0\\) : Bound orbit (elliptical) \\(E = 0\\) : Parabolic escape \\(E > 0\\) : Hyperbolic escape Gravitational Force Between Two Masses \\[F = \\frac{G m_1 m_2}{r^2}\\] Orbital Period (Kepler\u2019s Third Law) Applies to circular orbits:","title":"Formulas for Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#t-2pi-sqrtfracr3gm","text":"","title":"\\(\\(T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\)\\)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-2-equations-of-motion-in-2d","text":"From Newton\u2019s Law of Gravitation: \\[ \\frac{d^2\\vec{r}}{dt^2} = -\\frac{GM}{r^3}\\vec{r} \\] Let \\(\\vec{r} = (x, y)\\) , then: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{r^3}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{r^3} \\] To solve numerically, define the state vector \\([x, y, v_x, v_y]\\) with: \\[ \\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y $$ $$ \\frac{dv_x}{dt} = -\\frac{GMx}{r^3}, \\quad \\frac{dv_y}{dt} = -\\frac{GMy}{r^3} \\]","title":"Step 2: Equations of Motion in 2D"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-3-python-code-for-trajectory-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # mass of Earth [kg] R = 6.371e6 # radius of Earth [m] mu = G * M # gravitational parameter [m^3/s^2] # Define system of ODEs def dynamics(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Initial position: 400 km above Earth's surface x0 = R + 400000 # meters y0 = 0 # Initial velocities for different trajectory types v_values = [7300, 11180, 13000] # m/s: elliptical, parabolic, hyperbolic labels = ['Elliptical', 'Parabolic', 'Hyperbolic'] colors = ['blue', 'green', 'red'] plt.figure(figsize=(8, 8)) for v0, label, color in zip(v_values, labels, colors): vx0 = 0 vy0 = v0 state0 = [x0, y0, vx0, vy0] t_span = (0, 8000) t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(dynamics, t_span, state0, t_eval=t_eval, rtol=1e-9) x, y = sol.y[0], sol.y[1] plt.plot(x/1000, y/1000, label=label, color=color) # Earth theta = np.linspace(0, 2*np.pi, 300) plt.plot((R * np.cos(theta))/1000, (R * np.sin(theta))/1000, 'k', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Trajectories of a Payload Released Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Step 3: Python Code for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-4-interpretation","text":"Elliptical : Captured orbit. Occurs when the initial speed is below escape velocity. Parabolic : Boundary case. Object escapes with zero final velocity. Hyperbolic : Object escapes with excess energy. Relevant for deep space missions. These simulations reflect practical use cases in satellite deployment, space debris behavior, and interplanetary travel.","title":"Step 4: Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"Introduced energy-based classification of orbits. Derived motion equations for gravitational acceleration in 2D. Created a realistic simulation tool in Python to explore various escape conditions. Discussed relevance to orbital insertion and mission planning.","title":"Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 1. Explanation of the Topic Interference is a wave phenomenon that occurs when two or more wavefronts overlap in space. On a water surface, this is seen as regions where wave crests reinforce or cancel one another. Constructive Interference : when two waves meet in phase, they amplify. Destructive Interference : when two waves are out of phase, they cancel. This principle is central in understanding wave behavior, not only in water but also in acoustics, optics, and even quantum mechanics. 2. Mathematical Background 2.1 Single Point Source Wave Equation The wave from a single point source at \\((x_0, y_0)\\) is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: - \\(A\\) is the amplitude, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance to the point, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the phase offset. 2.2 Superposition of Multiple Waves If there are \\(N\\) identical, coherent sources, the total displacement at any point is: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) \\] Where \\(r_i\\) is the distance from the \\(i\\) -th source. 3. Geometry of the Sources Sources are placed at the vertices of a regular polygon (e.g., triangle, square, hexagon), distributed uniformly on a circle of radius \\(R\\) : \\[ x_i = R \\cos\\left(\\frac{2\\pi i}{N}\\right), \\quad y_i = R \\sin\\left(\\frac{2\\pi i}{N}\\right) \\] 4. Python Code: Interference Simulation import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 # Amplitude (m) wavelength = 1.0 # Wavelength (m) f = 1.0 # Frequency (Hz) k = 2 * np.pi / wavelength # Wave number w = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase # Source configuration N = 6 # Number of sources (polygon sides) R = 5.0 # Radius of polygon sources = [(R * np.cos(2 * np.pi * i / N), R * np.sin(2 * np.pi * i / N)) for i in range(N)] # Grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) T = 0 # Time snapshot # Function for one wave def wave(x, y, x0, y0, A, k, w, phi, t): r = np.sqrt((x - x0)**2 + (y - y0)**2) r[r == 0] = 1e-6 return A / np.sqrt(r) * np.cos(k * r - w * t + phi) # Total wave eta = np.zeros_like(X) for x0, y0 in sources: eta += wave(X, Y, x0, y0, A, k, w, phi, T) # Plot plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta, levels=100, cmap='viridis') plt.colorbar(label='Surface displacement \u03b7 (m)') plt.scatter(*zip(*sources), color='red', label='Sources') plt.title('Water Surface Interference Pattern') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.legend() plt.tight_layout() plt.show() 5. Analyze the Results Patterns : The plot shows bright and dark zones corresponding to constructive and destructive interference, respectively. The center often shows intense oscillation due to symmetrical source alignment. Symmetry : Because the sources are placed symmetrically (e.g., equilateral triangle, square), the interference patterns exhibit symmetrical structures. Parameter Dependence : Reducing the wavelength \\(\\lambda\\) increases the number of fringes (denser pattern). Changing the phase \\(\\phi\\) of one source distorts symmetry and shifts interference nodes. Increasing the amplitude \\(A\\) intensifies the wave height without affecting the pattern geometry. 6. Conclusions This simulation of wave interference on a water surface highlights the rich dynamics of wave superposition. By summing the displacements from multiple coherent sources, we observe: Constructive interference forming crests where waves align in phase. Destructive interference resulting in cancellation zones where waves are out of phase. Real-world relevance : These insights apply to sound waves, light diffraction, radar systems, and ocean engineering. Using simple principles of circular wave propagation and numerical tools like Python, students can intuitively understand: - how phase, amplitude, and geometry control wave outcomes, - and how symmetry and coherence lead to organized patterns. This makes the task valuable both for developing computational skills and for reinforcing theoretical physics concepts. 7. Explanation of the Code Parameters : The values of amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , wave number \\(k = \\frac{2\\pi}{\\lambda}\\) , and angular frequency \\(\\omega = 2\\pi f\\) are defined at the beginning. Source Placement : Sources are placed symmetrically at the vertices of a regular polygon. Their coordinates are computed using trigonometry on a circle of radius \\(R\\) . Grid Construction : A meshgrid of \\((x, y)\\) coordinates is created using np.meshgrid() to simulate the water surface over a region. Wave Function : A function calculates wave amplitude at each point from a single source based on distance \\(r\\) and applies the formula: $$ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) $$ Superposition : The contributions of all sources are summed point-wise using a loop. Visualization : A 2D contour plot is generated with plt.contourf() , which maps wave height to color gradients. Red and blue zones highlight wave peaks and troughs, while white or neutral zones indicate destructive cancellation. 8. Explanation of the Solution Step 1 : We chose a regular polygon (e.g., equilateral triangle) to place wave sources in a symmetric layout, which helps visualize balanced interference. Step 2 : We wrote the wave equation for each point source and applied the principle of superposition to calculate net displacement at each grid point. Step 3 : We explored the resulting interference pattern, studying how parameters like \\(\\lambda\\) , \\(\\phi\\) , and number of sources affect the structure.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-explanation-of-the-topic","text":"Interference is a wave phenomenon that occurs when two or more wavefronts overlap in space. On a water surface, this is seen as regions where wave crests reinforce or cancel one another. Constructive Interference : when two waves meet in phase, they amplify. Destructive Interference : when two waves are out of phase, they cancel. This principle is central in understanding wave behavior, not only in water but also in acoustics, optics, and even quantum mechanics.","title":"1. Explanation of the Topic"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-mathematical-background","text":"","title":"2. Mathematical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-single-point-source-wave-equation","text":"The wave from a single point source at \\((x_0, y_0)\\) is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: - \\(A\\) is the amplitude, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance to the point, - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the phase offset.","title":"2.1 Single Point Source Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#22-superposition-of-multiple-waves","text":"If there are \\(N\\) identical, coherent sources, the total displacement at any point is: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) \\] Where \\(r_i\\) is the distance from the \\(i\\) -th source.","title":"2.2 Superposition of Multiple Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-geometry-of-the-sources","text":"Sources are placed at the vertices of a regular polygon (e.g., triangle, square, hexagon), distributed uniformly on a circle of radius \\(R\\) : \\[ x_i = R \\cos\\left(\\frac{2\\pi i}{N}\\right), \\quad y_i = R \\sin\\left(\\frac{2\\pi i}{N}\\right) \\]","title":"3. Geometry of the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-python-code-interference-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1.0 # Amplitude (m) wavelength = 1.0 # Wavelength (m) f = 1.0 # Frequency (Hz) k = 2 * np.pi / wavelength # Wave number w = 2 * np.pi * f # Angular frequency phi = 0 # Initial phase # Source configuration N = 6 # Number of sources (polygon sides) R = 5.0 # Radius of polygon sources = [(R * np.cos(2 * np.pi * i / N), R * np.sin(2 * np.pi * i / N)) for i in range(N)] # Grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) T = 0 # Time snapshot # Function for one wave def wave(x, y, x0, y0, A, k, w, phi, t): r = np.sqrt((x - x0)**2 + (y - y0)**2) r[r == 0] = 1e-6 return A / np.sqrt(r) * np.cos(k * r - w * t + phi) # Total wave eta = np.zeros_like(X) for x0, y0 in sources: eta += wave(X, Y, x0, y0, A, k, w, phi, T) # Plot plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta, levels=100, cmap='viridis') plt.colorbar(label='Surface displacement \u03b7 (m)') plt.scatter(*zip(*sources), color='red', label='Sources') plt.title('Water Surface Interference Pattern') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.legend() plt.tight_layout() plt.show()","title":"4. Python Code: Interference Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyze-the-results","text":"Patterns : The plot shows bright and dark zones corresponding to constructive and destructive interference, respectively. The center often shows intense oscillation due to symmetrical source alignment. Symmetry : Because the sources are placed symmetrically (e.g., equilateral triangle, square), the interference patterns exhibit symmetrical structures. Parameter Dependence : Reducing the wavelength \\(\\lambda\\) increases the number of fringes (denser pattern). Changing the phase \\(\\phi\\) of one source distorts symmetry and shifts interference nodes. Increasing the amplitude \\(A\\) intensifies the wave height without affecting the pattern geometry.","title":"5. Analyze the Results"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-conclusions","text":"This simulation of wave interference on a water surface highlights the rich dynamics of wave superposition. By summing the displacements from multiple coherent sources, we observe: Constructive interference forming crests where waves align in phase. Destructive interference resulting in cancellation zones where waves are out of phase. Real-world relevance : These insights apply to sound waves, light diffraction, radar systems, and ocean engineering. Using simple principles of circular wave propagation and numerical tools like Python, students can intuitively understand: - how phase, amplitude, and geometry control wave outcomes, - and how symmetry and coherence lead to organized patterns. This makes the task valuable both for developing computational skills and for reinforcing theoretical physics concepts.","title":"6. Conclusions"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-explanation-of-the-code","text":"Parameters : The values of amplitude \\(A\\) , wavelength \\(\\lambda\\) , frequency \\(f\\) , wave number \\(k = \\frac{2\\pi}{\\lambda}\\) , and angular frequency \\(\\omega = 2\\pi f\\) are defined at the beginning. Source Placement : Sources are placed symmetrically at the vertices of a regular polygon. Their coordinates are computed using trigonometry on a circle of radius \\(R\\) . Grid Construction : A meshgrid of \\((x, y)\\) coordinates is created using np.meshgrid() to simulate the water surface over a region. Wave Function : A function calculates wave amplitude at each point from a single source based on distance \\(r\\) and applies the formula: $$ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) $$ Superposition : The contributions of all sources are summed point-wise using a loop. Visualization : A 2D contour plot is generated with plt.contourf() , which maps wave height to color gradients. Red and blue zones highlight wave peaks and troughs, while white or neutral zones indicate destructive cancellation.","title":"7. Explanation of the Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#8-explanation-of-the-solution","text":"Step 1 : We chose a regular polygon (e.g., equilateral triangle) to place wave sources in a symmetric layout, which helps visualize balanced interference. Step 2 : We wrote the wave equation for each point source and applied the principle of superposition to calculate net displacement at each grid point. Step 3 : We explored the resulting interference pattern, studying how parameters like \\(\\lambda\\) , \\(\\phi\\) , and number of sources affect the structure.","title":"8. Explanation of the Solution"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 1. Motivation The Lorentz force, expressed as: \\( \\(\\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B}\\) \\) governs the motion of charged particles in electric and magnetic fields. It plays a crucial role in many areas of physics, such as particle accelerators, plasma physics, astrophysics (e.g., auroras), and space propulsion systems. By understanding and simulating this force, we gain insight into the spiral or helical paths that charged particles follow under the influence of electromagnetic fields. 2. Goal Simulate the motion of a charged particle in the presence of constant electric and magnetic fields and analyze its trajectory based on the Lorentz force. 3. Theoretical Background Newton\u2019s second law applied to a charged particle gives: \\( \\(\\vec{F} = m\\vec{a} = m\\frac{d\\vec{v}}{dt} = q\\vec{E} + q(\\vec{v} \\times \\vec{B})\\) \\) Rewriting: \\( \\(\\frac{d\\vec{v}}{dt} = \\frac{q}{m}\\vec{E} + \\frac{q}{m}(\\vec{v} \\times \\vec{B})\\) \\) \\( \\(\\frac{d\\vec{r}}{dt} = \\vec{v}\\) \\) Where: - \\(\\vec{v} = (v_x, v_y, v_z)\\) is the velocity vector - \\(\\vec{r} = (x, y, z)\\) is the position vector - \\(q\\) is the charge (e.g., proton \\(1.602 \\times 10^{-19}\\) C) - \\(m\\) is the mass (e.g., proton \\(1.673 \\times 10^{-27}\\) kg) - \\(\\vec{E}\\) is the electric field (V/m) - \\(\\vec{B}\\) is the magnetic field (T) 4. Scenario Configuration Let\u2019s consider: - \\(\\vec{E} = (0, 1000, 0)\\) V/m (along the y-axis) - \\(\\vec{B} = (0, 0, 0.1)\\) T (along the z-axis) - Initial velocity: \\(\\vec{v}_0 = (1 \\times 10^5, 0, 0)\\) m/s - Time interval: \\(t \\in [0, 5 \\times 10^{-5}]\\) s Step-by-Step Solution: Simulating the Effects of the Lorentz Force Step 1: Identify Applications of the Lorentz Force The Lorentz force is critical in: Particle Accelerators : In cyclotrons, the magnetic field causes particles to move in circular paths while the electric field accelerates them. Astrophysics : Charged particles from the solar wind spiral along Earth\u2019s magnetic field lines, creating auroras. Plasma Confinement : In fusion reactors, magnetic fields confine plasma by forcing charged particles into helical paths. Step 2: Simulate Particle Motion We\u2019ll simulate the motion of a charged particle in combined electric and magnetic fields using Newton\u2019s second law: Newton's Second Law with Lorentz Force: $$ \\vec{F} = m\\vec{a} = m\\frac{d\\vec{v}}{dt} = q\\vec{E} + q(\\vec{v} \\times \\vec{B}) $$ Divide both sides by the particle's mass \\(m\\) : $$ \\frac{d\\vec{v}}{dt} = \\frac{q}{m}\\vec{E} + \\frac{q}{m}(\\vec{v} \\times \\vec{B}) $$ Update the particle\u2019s position over time as: $$ \\frac{d\\vec{r}}{dt} = \\vec{v} $$ Where: - \\(\\vec{r} = (x, y, z)\\) is the position vector - \\(\\vec{v} = (v_x, v_y, v_z)\\) is the velocity vector - \\(q\\) is the particle charge - \\(m\\) is the particle mass - \\(\\vec{E}\\) is the electric field - \\(\\vec{B}\\) is the magnetic field These equations form the system of differential equations we will solve numerically to trace the particle\u2019s motion under electromagnetic forces. 5. Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.602e-19 # Charge of proton (C) m = 1.673e-27 # Mass of proton (kg) E = np.array([0, 1000, 0]) # Electric field (V/m) B = np.array([0, 0, 0.1]) # Magnetic field (T) # Lorentz force system def lorentz_force(t, y): r = y[:3] v = y[3:] dvdt = (q/m) * (E + np.cross(v, B)) drdt = v return np.concatenate((drdt, dvdt)) # Initial conditions: [x, y, z, vx, vy, vz] y0 = np.array([0, 0, 0, 1e5, 0, 0]) # Time span t_span = (0, 5e-5) t_eval = np.linspace(*t_span, 1000) # Solve sol = solve_ivp(lorentz_force, t_span, y0, t_eval=t_eval) # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(sol.y[0], sol.y[1], sol.y[2], label='Particle Trajectory') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('Particle Trajectory under Lorentz Force') ax.legend() plt.tight_layout() plt.show() 6. Parameter Analysis Larmor Radius The radius of circular motion under magnetic field: \\( \\(r_L = \\frac{mv_\\perp}{|q|B}\\) \\) For our case: \\( \\(v_\\perp = v_{x0} = 1 \\times 10^5 \\, \\text{m/s}\\) \\) \\( \\(r_L = \\frac{(1.673 \\times 10^{-27})(1 \\times 10^5)}{(1.602 \\times 10^{-19})(0.1)} \\approx 0.01 \\, \\text{m}\\) \\) Drift Velocity The drift due to \\(\\vec{E} \\times \\vec{B}\\) : \\( \\(v_{drift} = \\frac{|\\vec{E}|}{|\\vec{B}|} = \\frac{1000}{0.1} = 10000 \\, \\text{m/s} \\quad \\text{(along x-axis)}\\) \\) 7. Results and Observations The particle shows a spiral motion due to the magnetic field. The center of the spiral moves due to the \\(\\vec{E} \\times \\vec{B}\\) drift. The Larmor radius matches the expected value from theoretical calculations. The trajectory confirms circular motion plus uniform drift \u2014 matching physical predictions. 8. Conclusion This simulation illustrates the fundamental role of the Lorentz force in charged particle dynamics. The spiral trajectory and lateral drift observed in the plots align with predictions from theory. These effects are central to technologies such as: - Cyclotrons and synchrotrons in particle physics - Magnetic confinement in fusion reactors - Auroras and space weather phenomena The Python code offers a flexible model to explore parameter changes and better understand electromagnetic forces in real systems.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-motivation","text":"The Lorentz force, expressed as: \\( \\(\\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B}\\) \\) governs the motion of charged particles in electric and magnetic fields. It plays a crucial role in many areas of physics, such as particle accelerators, plasma physics, astrophysics (e.g., auroras), and space propulsion systems. By understanding and simulating this force, we gain insight into the spiral or helical paths that charged particles follow under the influence of electromagnetic fields.","title":"1. Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-goal","text":"Simulate the motion of a charged particle in the presence of constant electric and magnetic fields and analyze its trajectory based on the Lorentz force.","title":"2. Goal"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-theoretical-background","text":"Newton\u2019s second law applied to a charged particle gives: \\( \\(\\vec{F} = m\\vec{a} = m\\frac{d\\vec{v}}{dt} = q\\vec{E} + q(\\vec{v} \\times \\vec{B})\\) \\) Rewriting: \\( \\(\\frac{d\\vec{v}}{dt} = \\frac{q}{m}\\vec{E} + \\frac{q}{m}(\\vec{v} \\times \\vec{B})\\) \\) \\( \\(\\frac{d\\vec{r}}{dt} = \\vec{v}\\) \\) Where: - \\(\\vec{v} = (v_x, v_y, v_z)\\) is the velocity vector - \\(\\vec{r} = (x, y, z)\\) is the position vector - \\(q\\) is the charge (e.g., proton \\(1.602 \\times 10^{-19}\\) C) - \\(m\\) is the mass (e.g., proton \\(1.673 \\times 10^{-27}\\) kg) - \\(\\vec{E}\\) is the electric field (V/m) - \\(\\vec{B}\\) is the magnetic field (T)","title":"3. Theoretical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-scenario-configuration","text":"Let\u2019s consider: - \\(\\vec{E} = (0, 1000, 0)\\) V/m (along the y-axis) - \\(\\vec{B} = (0, 0, 0.1)\\) T (along the z-axis) - Initial velocity: \\(\\vec{v}_0 = (1 \\times 10^5, 0, 0)\\) m/s - Time interval: \\(t \\in [0, 5 \\times 10^{-5}]\\) s","title":"4. Scenario Configuration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#step-by-step-solution-simulating-the-effects-of-the-lorentz-force","text":"","title":"Step-by-Step Solution: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#step-1-identify-applications-of-the-lorentz-force","text":"The Lorentz force is critical in: Particle Accelerators : In cyclotrons, the magnetic field causes particles to move in circular paths while the electric field accelerates them. Astrophysics : Charged particles from the solar wind spiral along Earth\u2019s magnetic field lines, creating auroras. Plasma Confinement : In fusion reactors, magnetic fields confine plasma by forcing charged particles into helical paths.","title":"Step 1: Identify Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#step-2-simulate-particle-motion","text":"We\u2019ll simulate the motion of a charged particle in combined electric and magnetic fields using Newton\u2019s second law: Newton's Second Law with Lorentz Force: $$ \\vec{F} = m\\vec{a} = m\\frac{d\\vec{v}}{dt} = q\\vec{E} + q(\\vec{v} \\times \\vec{B}) $$ Divide both sides by the particle's mass \\(m\\) : $$ \\frac{d\\vec{v}}{dt} = \\frac{q}{m}\\vec{E} + \\frac{q}{m}(\\vec{v} \\times \\vec{B}) $$ Update the particle\u2019s position over time as: $$ \\frac{d\\vec{r}}{dt} = \\vec{v} $$ Where: - \\(\\vec{r} = (x, y, z)\\) is the position vector - \\(\\vec{v} = (v_x, v_y, v_z)\\) is the velocity vector - \\(q\\) is the particle charge - \\(m\\) is the particle mass - \\(\\vec{E}\\) is the electric field - \\(\\vec{B}\\) is the magnetic field","title":"Step 2: Simulate Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#these-equations-form-the-system-of-differential-equations-we-will-solve-numerically-to-trace-the-particles-motion-under-electromagnetic-forces","text":"","title":"These equations form the system of differential equations we will solve numerically to trace the particle\u2019s motion under electromagnetic forces."},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.602e-19 # Charge of proton (C) m = 1.673e-27 # Mass of proton (kg) E = np.array([0, 1000, 0]) # Electric field (V/m) B = np.array([0, 0, 0.1]) # Magnetic field (T) # Lorentz force system def lorentz_force(t, y): r = y[:3] v = y[3:] dvdt = (q/m) * (E + np.cross(v, B)) drdt = v return np.concatenate((drdt, dvdt)) # Initial conditions: [x, y, z, vx, vy, vz] y0 = np.array([0, 0, 0, 1e5, 0, 0]) # Time span t_span = (0, 5e-5) t_eval = np.linspace(*t_span, 1000) # Solve sol = solve_ivp(lorentz_force, t_span, y0, t_eval=t_eval) # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(sol.y[0], sol.y[1], sol.y[2], label='Particle Trajectory') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('Particle Trajectory under Lorentz Force') ax.legend() plt.tight_layout() plt.show()","title":"5. Python Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-parameter-analysis","text":"Larmor Radius The radius of circular motion under magnetic field: \\( \\(r_L = \\frac{mv_\\perp}{|q|B}\\) \\) For our case: \\( \\(v_\\perp = v_{x0} = 1 \\times 10^5 \\, \\text{m/s}\\) \\) \\( \\(r_L = \\frac{(1.673 \\times 10^{-27})(1 \\times 10^5)}{(1.602 \\times 10^{-19})(0.1)} \\approx 0.01 \\, \\text{m}\\) \\) Drift Velocity The drift due to \\(\\vec{E} \\times \\vec{B}\\) : \\( \\(v_{drift} = \\frac{|\\vec{E}|}{|\\vec{B}|} = \\frac{1000}{0.1} = 10000 \\, \\text{m/s} \\quad \\text{(along x-axis)}\\) \\)","title":"6. Parameter Analysis"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-results-and-observations","text":"The particle shows a spiral motion due to the magnetic field. The center of the spiral moves due to the \\(\\vec{E} \\times \\vec{B}\\) drift. The Larmor radius matches the expected value from theoretical calculations. The trajectory confirms circular motion plus uniform drift \u2014 matching physical predictions.","title":"7. Results and Observations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#8-conclusion","text":"This simulation illustrates the fundamental role of the Lorentz force in charged particle dynamics. The spiral trajectory and lateral drift observed in the plots align with predictions from theory. These effects are central to technologies such as: - Cyclotrons and synchrotrons in particle physics - Magnetic confinement in fusion reactors - Auroras and space weather phenomena The Python code offers a flexible model to explore parameter changes and better understand electromagnetic forces in real systems.","title":"8. Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 1. Introduction In this problem, we explore how to compute the equivalent resistance of an electrical network using graph theory . This approach is powerful for complex circuits where standard series-parallel reduction becomes inefficient or infeasible. Each resistor is treated as a weighted edge between two nodes, with the resistance as the weight. We then simplify the graph step-by-step until only two terminal nodes remain, connected by a single effective resistance. 2. Theoretical Foundation We use these two fundamental rules: Series combination : For resistors \\(R_1\\) and \\(R_2\\) in series: \\( \\(R_{eq} = R_1 + R_2\\) \\) Parallel combination : For resistors \\(R_1\\) and \\(R_2\\) in parallel: \\( \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}\\) \\) In a graph context: Nodes \\(\\rightarrow\\) circuit junctions Edges \\(\\rightarrow\\) resistors with weights Series \\(\\rightarrow\\) degree-2 nodes Parallel \\(\\rightarrow\\) multiple edges between two nodes 3. Step-by-Step Algorithm Description Step 1: Input and Graph Construction Represent each resistor as an edge: (node1, node2, resistance) Store the edges in a graph data structure. Step 2: Identify Reductions While there are more than 2 nodes: Identify all parallel edges and replace them with a single edge using: \\[R_{eq}^{parallel} = \\left(\\sum_{i=1}^{n} \\frac{1}{R_i} \\right)^{-1}\\] Identify series nodes (degree = 2) not being terminals and merge edges: \\[R_{eq}^{series} = R_1 + R_2\\] Step 3: Output Final Resistance When only two nodes remain (terminals), return the single edge's weight. 4. Python Implementation import networkx as nx import matplotlib.pyplot as plt def series_resistance(R1, R2): return R1 + R2 def parallel_resistance(R1, R2): return (R1 * R2) / (R1 + R2) R1 = 4 R2 = 6 R3 = 3 R4 = 2 G = nx.Graph() G.add_edge(\"A\", \"B\", weight=R1) G.add_edge(\"B\", \"D\", weight=R2) G.add_edge(\"A\", \"C\", weight=R3) G.add_edge(\"C\", \"D\", weight=R4) pos = { \"A\": (0, 1), \"B\": (2, 1), \"C\": (0, 0), \"D\": (2, 0) } labels = nx.get_edge_attributes(G, \"weight\") plt.figure(figsize=(6, 4)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700, font_size=10) nx.draw_networkx_edge_labels(G, pos, edge_labels={k: f\"{v}\u03a9\" for k, v in labels.items()}) plt.title(\"Graph Representation of a Resistor Network\") plt.tight_layout() plt.show() 5. Examples. Test on Examples Series Circuit R1 = 2 R2 = 3 R_series = R1 + R2 print(\"Series Circuit:\") print(f\"R1 = {R1} \u03a9, R2 = {R2} \u03a9\") print(f\"Equivalent Resistance = {R_series} \u03a9\\n\") Parallel Circuit R1 = 2 R2 = 3 R_parallel = (R1 * R2) / (R1 + R2) print(\"Parallel Circuit:\") print(f\"R1 = {R1} \u03a9, R2 = {R2} \u03a9\") print(f\"Equivalent Resistance = {R_parallel:.2f} \u03a9\\n\") Nested Circuit: R1 in series with (R2 || R3) R1 = 1 R2 = 2 R3 = 2 R_parallel = (R2 * R3) / (R2 + R3) R_nested = R1 + R_parallel print(\"Nested Circuit:\") print(f\"R1 = {R1} \u03a9, R2 = {R2} \u03a9, R3 = {R3} \u03a9\") print(f\"R2 || R3 = {R_parallel:.2f} \u03a9\") print(f\"Equivalent Resistance = {R_nested:.2f} \u03a9\") 6: Analysis (with equations) Series: \\( \\(R_{eq} = R_1 + R_2 = 2 + 3 = 5\\) \\) Parallel: \\( \\(R_{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} = \\frac{2 \\cdot 3}{2 + 3} = 1.2\\) \\) Nested: \\( \\(R_1 = 1,\\quad R_2 = 2,\\quad R_3 = 2\\) \\) \\( \\(R_{23} = \\frac{2 \\cdot 2}{2 + 2} = 1,\\quad R_{nested} = R_1 + R_{23} = 1 + 1 = 2\\) \\) 7. Performance and Improvements Time Complexity : Worst-case \\(O(n^2)\\) due to repeated edge scanning. Improvement : Use a union-find data structure or Kirchhoff\u2019s laws with matrix methods for larger graphs. 8. Conclusion This method provides a reliable and scalable way to compute equivalent resistance in complex electrical networks. By reducing the network iteratively via graph transformations, even nested series-parallel circuits become manageable, enabling automation and deeper understanding through the lens of graph theory.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-introduction","text":"In this problem, we explore how to compute the equivalent resistance of an electrical network using graph theory . This approach is powerful for complex circuits where standard series-parallel reduction becomes inefficient or infeasible. Each resistor is treated as a weighted edge between two nodes, with the resistance as the weight. We then simplify the graph step-by-step until only two terminal nodes remain, connected by a single effective resistance.","title":"1. Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-theoretical-foundation","text":"We use these two fundamental rules: Series combination : For resistors \\(R_1\\) and \\(R_2\\) in series: \\( \\(R_{eq} = R_1 + R_2\\) \\) Parallel combination : For resistors \\(R_1\\) and \\(R_2\\) in parallel: \\( \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}\\) \\) In a graph context: Nodes \\(\\rightarrow\\) circuit junctions Edges \\(\\rightarrow\\) resistors with weights Series \\(\\rightarrow\\) degree-2 nodes Parallel \\(\\rightarrow\\) multiple edges between two nodes","title":"2. Theoretical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-step-by-step-algorithm-description","text":"","title":"3. Step-by-Step Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-input-and-graph-construction","text":"Represent each resistor as an edge: (node1, node2, resistance) Store the edges in a graph data structure.","title":"Step 1: Input and Graph Construction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-identify-reductions","text":"While there are more than 2 nodes: Identify all parallel edges and replace them with a single edge using: \\[R_{eq}^{parallel} = \\left(\\sum_{i=1}^{n} \\frac{1}{R_i} \\right)^{-1}\\] Identify series nodes (degree = 2) not being terminals and merge edges: \\[R_{eq}^{series} = R_1 + R_2\\]","title":"Step 2: Identify Reductions"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-3-output-final-resistance","text":"When only two nodes remain (terminals), return the single edge's weight.","title":"Step 3: Output Final Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-python-implementation","text":"import networkx as nx import matplotlib.pyplot as plt def series_resistance(R1, R2): return R1 + R2 def parallel_resistance(R1, R2): return (R1 * R2) / (R1 + R2) R1 = 4 R2 = 6 R3 = 3 R4 = 2 G = nx.Graph() G.add_edge(\"A\", \"B\", weight=R1) G.add_edge(\"B\", \"D\", weight=R2) G.add_edge(\"A\", \"C\", weight=R3) G.add_edge(\"C\", \"D\", weight=R4) pos = { \"A\": (0, 1), \"B\": (2, 1), \"C\": (0, 0), \"D\": (2, 0) } labels = nx.get_edge_attributes(G, \"weight\") plt.figure(figsize=(6, 4)) nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700, font_size=10) nx.draw_networkx_edge_labels(G, pos, edge_labels={k: f\"{v}\u03a9\" for k, v in labels.items()}) plt.title(\"Graph Representation of a Resistor Network\") plt.tight_layout() plt.show()","title":"4. Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-examples-test-on-examples","text":"","title":"5. Examples. Test on Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-circuit","text":"R1 = 2 R2 = 3 R_series = R1 + R2 print(\"Series Circuit:\") print(f\"R1 = {R1} \u03a9, R2 = {R2} \u03a9\") print(f\"Equivalent Resistance = {R_series} \u03a9\\n\")","title":"Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-circuit","text":"R1 = 2 R2 = 3 R_parallel = (R1 * R2) / (R1 + R2) print(\"Parallel Circuit:\") print(f\"R1 = {R1} \u03a9, R2 = {R2} \u03a9\") print(f\"Equivalent Resistance = {R_parallel:.2f} \u03a9\\n\")","title":"Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#nested-circuit-r1-in-series-with-r2-r3","text":"R1 = 1 R2 = 2 R3 = 2 R_parallel = (R2 * R3) / (R2 + R3) R_nested = R1 + R_parallel print(\"Nested Circuit:\") print(f\"R1 = {R1} \u03a9, R2 = {R2} \u03a9, R3 = {R3} \u03a9\") print(f\"R2 || R3 = {R_parallel:.2f} \u03a9\") print(f\"Equivalent Resistance = {R_nested:.2f} \u03a9\")","title":"Nested Circuit: R1 in series with (R2 || R3)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#6-analysis-with-equations","text":"","title":"6: Analysis (with equations)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series","text":"","title":"Series:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#r_eq-r_1-r_2-2-3-5","text":"","title":"\\(\\(R_{eq} = R_1 + R_2 = 2 + 3 = 5\\)\\)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel","text":"","title":"Parallel:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#r_eq-fracr_1-cdot-r_2r_1-r_2-frac2-cdot-32-3-12","text":"","title":"\\(\\(R_{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} = \\frac{2 \\cdot 3}{2 + 3} = 1.2\\)\\)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#nested","text":"","title":"Nested:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#r_1-1quad-r_2-2quad-r_3-2","text":"","title":"\\(\\(R_1 = 1,\\quad R_2 = 2,\\quad R_3 = 2\\)\\)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#r_23-frac2-cdot-22-2-1quad-r_nested-r_1-r_23-1-1-2","text":"","title":"\\(\\(R_{23} = \\frac{2 \\cdot 2}{2 + 2} = 1,\\quad R_{nested} = R_1 + R_{23} = 1 + 1 = 2\\)\\)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#7-performance-and-improvements","text":"Time Complexity : Worst-case \\(O(n^2)\\) due to repeated edge scanning. Improvement : Use a union-find data structure or Kirchhoff\u2019s laws with matrix methods for larger graphs.","title":"7. Performance and Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#8-conclusion","text":"This method provides a reliable and scalable way to compute equivalent resistance in complex electrical networks. By reducing the network iteratively via graph transformations, even nested series-parallel circuits become manageable, enabling automation and deeper understanding through the lens of graph theory.","title":"8. Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Step-by-Step Solution: Exploring the Central Limit Theorem through Simulations Step 1: Understanding the Central Limit Theorem (CLT) The Central Limit Theorem (CLT) is a fundamental concept in statistics. It describes the behavior of the sample mean of a population as the sample size increases. According to the CLT, the distribution of sample means tends to become approximately normal even if the original population distribution is not normal \u2014 provided the sample size is sufficiently large. Mathematically, if we draw samples of size \\(n\\) from a population with mean \\(\\mu\\) and standard deviation \\(\\sigma\\) , then the sampling distribution of the mean \\(\\bar{X}\\) is approximately: \\[ \\bar{X} \\sim N\\left(\\mu, \\frac{\\sigma}{\\sqrt{n}}\\right) \\] This approximation becomes more accurate as \\(n\\) increases. Step 2: Simulated Populations To observe the Central Limit Theorem in practice, we consider three types of populations: Uniform Distribution : A flat distribution where all values are equally likely within the range [0, 1]. PDF: \\( \\(f(x) = 1 \\quad \\text{for } 0 \\le x \\le 1\\) \\) Mean: \\(\\mu = \\frac{0 + 1}{2} = 0.5\\) Std Dev: \\(\\sigma = \\frac{1}{\\sqrt{12}} \\approx 0.2887\\) Exponential Distribution : A distribution commonly used to model time between events. PDF (with \\(\\lambda = 1\\) ): \\( \\(f(x) = \\lambda e^{-\\lambda x} \\quad \\text{for } x \\ge 0\\) \\) Mean: \\(\\mu = \\frac{1}{\\lambda} = 1\\) Std Dev: \\(\\sigma = \\frac{1}{\\lambda} = 1\\) Binomial Distribution : A discrete distribution that models the number of successes in fixed trials. Mean: \\(\\mu = np\\) Std Dev: \\(\\sigma = \\sqrt{np(1-p)}\\) Step 3: Simulating and Sampling We take repeated random samples of sizes \\(n = 5, 10, 30, 50\\) from each distribution and calculate their means. Repeating this 1000 times gives us a sampling distribution of the mean . We then visualize how it converges to a normal shape. Step 4: Graphical Simulation import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Simulation Parameters population_size = 10000 num_samples = 1000 sample_sizes = [5, 10, 30, 50] # Uniform and Exponential Populations uniform_pop = np.random.uniform(0, 1, population_size) expon_pop = np.random.exponential(scale=1, size=population_size) # Setup subplots: 2 columns x 4 rows fig, axs = plt.subplots(4, 2, figsize=(12, 16)) plt.subplots_adjust(hspace=0.5) color = '#4A90E2' # Sampling and plotting distributions = [('Uniform', uniform_pop), ('Exponential', expon_pop)] for col, (dist_name, pop_data) in enumerate(distributions): for row, n in enumerate(sample_sizes): means = [np.mean(np.random.choice(pop_data, size=n)) for _ in range(num_samples)] ax = axs[row, col] sns.histplot(means, kde=True, stat=\"density\", bins=30, color=color, ax=ax) ax.set_title(f\"{dist_name}, n = {n}\") ax.set_xlabel(\"Sample Mean\") ax.set_ylabel(\"Density\") ax.legend([f\"n = {n}\"]) plt.suptitle(\"Sampling Distributions of Sample Means\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.97]) plt.show() Step 5: Explanation of the Graphs Each subplot shows how the distribution of sample means behaves for a given sample size \\(n\\) . Here's what we observe: Uniform Distribution : For small \\(n\\) , the sampling distribution is still somewhat uniform. As \\(n\\) increases (e.g., \\(n=50\\) ), it becomes bell-shaped, approaching normality. Exponential Distribution : Originally very skewed, but the sample means become more symmetric with larger \\(n\\) . Convergence to normal is slower compared to the uniform distribution due to higher variance. This visual transformation demonstrates the power of the Central Limit Theorem \u2014 normality emerges even from non-normal populations. Step 6: Interpretation and Practical Value Effect of Sample Size : Larger samples produce smoother, more normal-looking sample mean distributions. Population Shape Matters Less : Even if the original population is skewed, the sampling mean becomes normal. Variance Impact : Populations with higher variance converge more slowly to normality. Step 7: Real-Life Applications Estimation : CLT justifies estimating population parameters (like the mean) from samples. Manufacturing : Quality control uses CLT to ensure parts meet tolerances based on sample means. Finance : CLT explains why returns often approximate normal distributions in models. Step 8: Conclusion Through this simulation, we confirmed that the Central Limit Theorem holds across different distributions and sample sizes. As the number of samples grows, the sampling distribution of the mean consistently becomes more normal , regardless of whether the population is uniform , exponential , or binomial . This makes the CLT one of the most powerful tools in all of statistics.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-by-step-solution-exploring-the-central-limit-theorem-through-simulations","text":"","title":"Step-by-Step Solution: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-1-understanding-the-central-limit-theorem-clt","text":"The Central Limit Theorem (CLT) is a fundamental concept in statistics. It describes the behavior of the sample mean of a population as the sample size increases. According to the CLT, the distribution of sample means tends to become approximately normal even if the original population distribution is not normal \u2014 provided the sample size is sufficiently large. Mathematically, if we draw samples of size \\(n\\) from a population with mean \\(\\mu\\) and standard deviation \\(\\sigma\\) , then the sampling distribution of the mean \\(\\bar{X}\\) is approximately: \\[ \\bar{X} \\sim N\\left(\\mu, \\frac{\\sigma}{\\sqrt{n}}\\right) \\] This approximation becomes more accurate as \\(n\\) increases.","title":"Step 1: Understanding the Central Limit Theorem (CLT)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-2-simulated-populations","text":"To observe the Central Limit Theorem in practice, we consider three types of populations: Uniform Distribution : A flat distribution where all values are equally likely within the range [0, 1]. PDF: \\( \\(f(x) = 1 \\quad \\text{for } 0 \\le x \\le 1\\) \\) Mean: \\(\\mu = \\frac{0 + 1}{2} = 0.5\\) Std Dev: \\(\\sigma = \\frac{1}{\\sqrt{12}} \\approx 0.2887\\) Exponential Distribution : A distribution commonly used to model time between events. PDF (with \\(\\lambda = 1\\) ): \\( \\(f(x) = \\lambda e^{-\\lambda x} \\quad \\text{for } x \\ge 0\\) \\) Mean: \\(\\mu = \\frac{1}{\\lambda} = 1\\) Std Dev: \\(\\sigma = \\frac{1}{\\lambda} = 1\\) Binomial Distribution : A discrete distribution that models the number of successes in fixed trials. Mean: \\(\\mu = np\\) Std Dev: \\(\\sigma = \\sqrt{np(1-p)}\\)","title":"Step 2: Simulated Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-3-simulating-and-sampling","text":"We take repeated random samples of sizes \\(n = 5, 10, 30, 50\\) from each distribution and calculate their means. Repeating this 1000 times gives us a sampling distribution of the mean . We then visualize how it converges to a normal shape.","title":"Step 3: Simulating and Sampling"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-4-graphical-simulation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Simulation Parameters population_size = 10000 num_samples = 1000 sample_sizes = [5, 10, 30, 50] # Uniform and Exponential Populations uniform_pop = np.random.uniform(0, 1, population_size) expon_pop = np.random.exponential(scale=1, size=population_size) # Setup subplots: 2 columns x 4 rows fig, axs = plt.subplots(4, 2, figsize=(12, 16)) plt.subplots_adjust(hspace=0.5) color = '#4A90E2' # Sampling and plotting distributions = [('Uniform', uniform_pop), ('Exponential', expon_pop)] for col, (dist_name, pop_data) in enumerate(distributions): for row, n in enumerate(sample_sizes): means = [np.mean(np.random.choice(pop_data, size=n)) for _ in range(num_samples)] ax = axs[row, col] sns.histplot(means, kde=True, stat=\"density\", bins=30, color=color, ax=ax) ax.set_title(f\"{dist_name}, n = {n}\") ax.set_xlabel(\"Sample Mean\") ax.set_ylabel(\"Density\") ax.legend([f\"n = {n}\"]) plt.suptitle(\"Sampling Distributions of Sample Means\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.97]) plt.show()","title":"Step 4: Graphical Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-5-explanation-of-the-graphs","text":"Each subplot shows how the distribution of sample means behaves for a given sample size \\(n\\) . Here's what we observe: Uniform Distribution : For small \\(n\\) , the sampling distribution is still somewhat uniform. As \\(n\\) increases (e.g., \\(n=50\\) ), it becomes bell-shaped, approaching normality. Exponential Distribution : Originally very skewed, but the sample means become more symmetric with larger \\(n\\) . Convergence to normal is slower compared to the uniform distribution due to higher variance. This visual transformation demonstrates the power of the Central Limit Theorem \u2014 normality emerges even from non-normal populations.","title":"Step 5: Explanation of the Graphs"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-6-interpretation-and-practical-value","text":"Effect of Sample Size : Larger samples produce smoother, more normal-looking sample mean distributions. Population Shape Matters Less : Even if the original population is skewed, the sampling mean becomes normal. Variance Impact : Populations with higher variance converge more slowly to normality.","title":"Step 6: Interpretation and Practical Value"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-7-real-life-applications","text":"Estimation : CLT justifies estimating population parameters (like the mean) from samples. Manufacturing : Quality control uses CLT to ensure parts meet tolerances based on sample means. Finance : CLT explains why returns often approximate normal distributions in models.","title":"Step 7: Real-Life Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-8-conclusion","text":"Through this simulation, we confirmed that the Central Limit Theorem holds across different distributions and sample sizes. As the number of samples grows, the sampling distribution of the mean consistently becomes more normal , regardless of whether the population is uniform , exponential , or binomial . This makes the CLT one of the most powerful tools in all of statistics.","title":"Step 8: Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}