{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Step 1: Understanding Projectile Motion Projectile motion follows two independent components: 1. Horizontal Motion : Moves at constant velocity. 2. Vertical Motion : Affected by gravity. Ignoring air resistance, we assume: - Initial velocity: \\(v_0\\) - Launch angle: \\(\\theta\\) - Gravity: \\(g\\) The goal is to find how the range depends on \\(\\theta\\) . Step 2: Deriving the Equations of Motion Using kinematic equations: Horizontal Motion: Initial horizontal velocity: $$ v_{x0} = v_0\\cos(\\theta) $$ Horizontal displacement at time \\(t\\) : $$ x(t) = v_0\\cos(\\theta) t $$ Vertical Motion: Initial vertical velocity: $$ v_{y0} = v_0\\sin(\\theta) $$ Vertical displacement at time \\(t\\) : $$ y(t) = v_0\\sin(\\theta) t - \\frac{1}{2}gt^2 $$ The projectile reaches the ground when \\(y = 0\\) . Solving for \\(t\\) : \\[ t_f = \\frac{2v_0\\sin(\\theta)}{g}. \\] Step 3: Calculating the Range The range is the horizontal distance traveled before landing: \\[ R = x(t_f) = v_0\\cos(\\theta) t_f. \\] Substituting \\(t_f\\) : \\[ R = v_0\\cos(\\theta) \\times \\frac{2v_0\\sin(\\theta)}{g}. \\] Using \\(\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)\\) : \\[ R = \\frac{v_0^2\\sin(2\\theta)}{g}. \\] Step 4: Analyzing the Range Equation Effect of Angle : Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , i.e., \\(\\theta = 45^\\circ\\) . The function is symmetric about \\(45^\\circ\\) , meaning angles like \\(30^\\circ\\) and \\(60^\\circ\\) yield the same range. Effect of Initial Velocity : Range increases quadratically with \\(v_0\\) . Effect of Gravity : Increasing \\(g\\) decreases range, as expected in stronger gravitational fields. import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees radians = np.radians(angles) # Convert to radians # Compute range ranges = (v0**2 * np.sin(2 * radians)) / g # Plot results plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=r\"$R = \\frac{v_0^2\\sin(2\\theta)}{g}$\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show() Step 5: Practical Applications Sports : Finding the best angle for throwing a javelin or soccer ball. Engineering : Estimating landing zones for projectiles. Astronomy : Calculating trajectories of objects in space. Step 6: Model Limitations No Air Resistance : Real-world projectiles experience drag, which shortens the range. Different Heights : If launched from or landing on different heights, calculations must be adjusted. Wind Effects : Wind can increase or decrease range unpredictably. For greater accuracy, numerical methods (e.g., solving differential equations with drag) are required.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-understanding-projectile-motion","text":"Projectile motion follows two independent components: 1. Horizontal Motion : Moves at constant velocity. 2. Vertical Motion : Affected by gravity. Ignoring air resistance, we assume: - Initial velocity: \\(v_0\\) - Launch angle: \\(\\theta\\) - Gravity: \\(g\\) The goal is to find how the range depends on \\(\\theta\\) .","title":"Step 1: Understanding Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-deriving-the-equations-of-motion","text":"Using kinematic equations:","title":"Step 2: Deriving the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Initial horizontal velocity: $$ v_{x0} = v_0\\cos(\\theta) $$ Horizontal displacement at time \\(t\\) : $$ x(t) = v_0\\cos(\\theta) t $$","title":"Horizontal Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Initial vertical velocity: $$ v_{y0} = v_0\\sin(\\theta) $$ Vertical displacement at time \\(t\\) : $$ y(t) = v_0\\sin(\\theta) t - \\frac{1}{2}gt^2 $$ The projectile reaches the ground when \\(y = 0\\) . Solving for \\(t\\) : \\[ t_f = \\frac{2v_0\\sin(\\theta)}{g}. \\]","title":"Vertical Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-calculating-the-range","text":"The range is the horizontal distance traveled before landing: \\[ R = x(t_f) = v_0\\cos(\\theta) t_f. \\] Substituting \\(t_f\\) : \\[ R = v_0\\cos(\\theta) \\times \\frac{2v_0\\sin(\\theta)}{g}. \\] Using \\(\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)\\) : \\[ R = \\frac{v_0^2\\sin(2\\theta)}{g}. \\]","title":"Step 3: Calculating the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-analyzing-the-range-equation","text":"Effect of Angle : Maximum range occurs when \\(\\sin(2\\theta) = 1\\) , i.e., \\(\\theta = 45^\\circ\\) . The function is symmetric about \\(45^\\circ\\) , meaning angles like \\(30^\\circ\\) and \\(60^\\circ\\) yield the same range. Effect of Initial Velocity : Range increases quadratically with \\(v_0\\) . Effect of Gravity : Increasing \\(g\\) decreases range, as expected in stronger gravitational fields. import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees radians = np.radians(angles) # Convert to radians # Compute range ranges = (v0**2 * np.sin(2 * radians)) / g # Plot results plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=r\"$R = \\frac{v_0^2\\sin(2\\theta)}{g}$\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Angle of Projection\") plt.legend() plt.grid() plt.show()","title":"Step 4: Analyzing the Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-5-practical-applications","text":"Sports : Finding the best angle for throwing a javelin or soccer ball. Engineering : Estimating landing zones for projectiles. Astronomy : Calculating trajectories of objects in space.","title":"Step 5: Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-6-model-limitations","text":"No Air Resistance : Real-world projectiles experience drag, which shortens the range. Different Heights : If launched from or landing on different heights, calculations must be adjusted. Wind Effects : Wind can increase or decrease range unpredictably. For greater accuracy, numerical methods (e.g., solving differential equations with drag) are required.","title":"Step 6: Model Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Step 1: Theoretical Foundation We consider the equation for a forced damped pendulum: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t)\\] This includes damping \\(b\\) , gravity \\(g\\) , length \\(L\\) , and periodic forcing \\(A\\cos(\\omega t)\\) . To solve it numerically, we rewrite it as a system of first-order ODEs. Step 1.1: Approximate Solution for Small-Angle Oscillations To simplify the analysis, we consider the small-angle approximation: \\[\\sin\\theta \\approx \\theta\\] Substituting this into the original equation gives a linear second-order nonhomogeneous differential equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\] This is a standard linear ODE with constant coefficients and a cosine forcing term. The general solution consists of two parts: 1. Homogeneous Solution Solve the homogeneous equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = 0\\] Assume a solution of the form \\(\\theta_h(t) = e^{\\lambda t}\\) : Then: \\[\\lambda^2 + b\\lambda + \\frac{g}{L} = 0\\] Solve the characteristic equation: If the discriminant \\(D = b^2 - 4\\frac{g}{L} > 0\\) : overdamped If \\(D = 0\\) : critically damped If \\(D < 0\\) : underdamped (oscillatory), which gives: \\[\\theta_h(t) = e^{-\\frac{b}{2}t}(C_1\\cos(\\omega_0 t) + C_2\\sin(\\omega_0 t))\\] where: \\[\\omega_0 = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}}\\] 2. Particular Solution Assume a solution of the form: \\[\\theta_p(t) = B\\cos(\\omega t) + C\\sin(\\omega t)\\] Plug into the ODE and match coefficients. After simplification: The steady-state solution is: \\[\\theta_p(t) = \\frac{A}{\\sqrt{(\\frac{g}{L} - \\omega^2)^2 + (b\\omega)^2}} \\cos(\\omega t - \\delta)\\] where the phase shift \\(\\delta\\) is given by: \\[\\tan(\\delta) = \\frac{b\\omega}{\\frac{g}{L} - \\omega^2}\\] Final Approximate Solution: Combining both parts: \\[\\theta(t) = \\theta_h(t) + \\theta_p(t)\\] In the long term, the homogeneous part decays due to damping, and the system reaches a steady-state periodic solution with amplitude and phase depending on \\(A\\) , \\(b\\) , \\(\\omega\\) , and \\(\\frac{g}{L}\\) . This approximation is useful for analyzing resonance and predicting the system\u2019s response under small displacements. Step 2: System of Equations. Analysis of Dynamics: Let: \\(x_1 = \\theta\\) \\(x_2 = \\frac{d\\theta}{dt}\\) Then: \\[\\frac{dx_1}{dt} = x_2$$ $$\\frac{dx_2}{dt} = -b x_2 - \\frac{g}{L} \\sin(x_1) + A \\cos(\\omega t)\\] Step 3: Angle and Phase Space Simulation The forced damped pendulum model is relevant to various engineering and physical systems. Some real-world examples include: Energy harvesting systems , where mechanical vibrations are converted into electrical energy using oscillating parts. Suspension bridges , where damping and periodic forces play a role in stabilizing the structure under wind or traffic loads. Oscillating electrical circuits (e.g., RLC circuits), which behave analogously to mechanical oscillators with damping and driving forces. Biomechanics , such as modeling the motion of limbs or joints under muscle activation and external load. Step 4: Poincar\u00e9 Section Python Code: Combined Pendulum Plots (\u03b8(t), \u03c9(t), Phase Portrait) python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 L = 1.0 b = 0.3 A = 1.2 w = 2.0 # Initial conditions theta0 = 0.2 omega0 = 0.0 y0 = [theta0, omega0] # Time setup t_start = 0 t_end = 20 num_points = 5000 t_vals = np.linspace(t_start, t_end, num_points) # Define the system def pendulum(t, y): theta = y[0] omega = y[1] dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(w * t) return [dtheta_dt, domega_dt] # Solve the system sol = solve_ivp(pendulum, [t_start, t_end], y0, t_eval=t_vals) theta = sol.y[0] omega = sol.y[1] time = sol.t # Plot results in subplots fig, axs = plt.subplots(2, 2, figsize=(12, 8)) fig.suptitle('Forced Damped Pendulum Simulation', fontsize=16) # \u03b8(t) axs[0, 0].plot(time, theta, label='\u03b8(t)', color='royalblue') axs[0, 0].set_title('Angle vs Time') axs[0, 0].set_xlabel('Time (s)') axs[0, 0].set_ylabel('Angle \u03b8 (rad)') axs[0, 0].grid(True) axs[0, 0].legend() # \u03c9(t) axs[0, 1].plot(time, omega, label='d\u03b8/dt(t)', color='orange') axs[0, 1].set_title('Angular Velocity vs Time') axs[0, 1].set_xlabel('Time (s)') axs[0, 1].set_ylabel('Angular Velocity (rad/s)') axs[0, 1].grid(True) axs[0, 1].legend() # Phase portrait: \u03c9 vs \u03b8 axs[1, 0].plot(theta, omega, label='Phase Portrait', color='steelblue') axs[1, 0].set_title('Phase Portrait') axs[1, 0].set_xlabel('Angle \u03b8 (rad)') axs[1, 0].set_ylabel('Angular Velocity d\u03b8/dt (rad/s)') axs[1, 0].grid(True) axs[1, 0].legend() # Hide unused subplot axs[1, 1].axis('off') plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.show() Explanation of the Code Parameters : The script defines physical parameters including \\(g\\) (gravity), \\(L\\) (length), \\(b\\) (damping), \\(A\\) (amplitude of forcing), and \\(\\omega\\) (driving frequency). ODE System : The nonlinear second-order differential equation is rewritten as a system of first-order ODEs: $$ \\frac{d\\theta}{dt} = \\omega, \\quad \\frac{d\\omega}{dt} = -b\\omega - \\frac{g}{L} \\sin\\theta + A \\cos(\\omega t) $$ Numerical Solution : The system is solved using solve_ivp from scipy.integrate , which implements a Runge-Kutta method with adaptive time stepping. Plots : \\(\\theta(t)\\) \u2014 Angle over time \\(\\dot{\\theta}(t)\\) \u2014 Angular velocity over time Phase portrait \u2014 \\(\\dot{\\theta}\\) vs. \\(\\theta\\)","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-1-theoretical-foundation","text":"We consider the equation for a forced damped pendulum: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t)\\] This includes damping \\(b\\) , gravity \\(g\\) , length \\(L\\) , and periodic forcing \\(A\\cos(\\omega t)\\) . To solve it numerically, we rewrite it as a system of first-order ODEs.","title":"Step 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-11-approximate-solution-for-small-angle-oscillations","text":"To simplify the analysis, we consider the small-angle approximation: \\[\\sin\\theta \\approx \\theta\\] Substituting this into the original equation gives a linear second-order nonhomogeneous differential equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\] This is a standard linear ODE with constant coefficients and a cosine forcing term. The general solution consists of two parts:","title":"Step 1.1: Approximate Solution for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-homogeneous-solution","text":"Solve the homogeneous equation: \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = 0\\] Assume a solution of the form \\(\\theta_h(t) = e^{\\lambda t}\\) : Then: \\[\\lambda^2 + b\\lambda + \\frac{g}{L} = 0\\] Solve the characteristic equation: If the discriminant \\(D = b^2 - 4\\frac{g}{L} > 0\\) : overdamped If \\(D = 0\\) : critically damped If \\(D < 0\\) : underdamped (oscillatory), which gives: \\[\\theta_h(t) = e^{-\\frac{b}{2}t}(C_1\\cos(\\omega_0 t) + C_2\\sin(\\omega_0 t))\\] where: \\[\\omega_0 = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}}\\]","title":"1. Homogeneous Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-particular-solution","text":"Assume a solution of the form: \\[\\theta_p(t) = B\\cos(\\omega t) + C\\sin(\\omega t)\\] Plug into the ODE and match coefficients. After simplification: The steady-state solution is: \\[\\theta_p(t) = \\frac{A}{\\sqrt{(\\frac{g}{L} - \\omega^2)^2 + (b\\omega)^2}} \\cos(\\omega t - \\delta)\\] where the phase shift \\(\\delta\\) is given by: \\[\\tan(\\delta) = \\frac{b\\omega}{\\frac{g}{L} - \\omega^2}\\]","title":"2. Particular Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#final-approximate-solution","text":"Combining both parts: \\[\\theta(t) = \\theta_h(t) + \\theta_p(t)\\] In the long term, the homogeneous part decays due to damping, and the system reaches a steady-state periodic solution with amplitude and phase depending on \\(A\\) , \\(b\\) , \\(\\omega\\) , and \\(\\frac{g}{L}\\) . This approximation is useful for analyzing resonance and predicting the system\u2019s response under small displacements.","title":"Final Approximate Solution:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-2-system-of-equations-analysis-of-dynamics","text":"Let: \\(x_1 = \\theta\\) \\(x_2 = \\frac{d\\theta}{dt}\\) Then: \\[\\frac{dx_1}{dt} = x_2$$ $$\\frac{dx_2}{dt} = -b x_2 - \\frac{g}{L} \\sin(x_1) + A \\cos(\\omega t)\\]","title":"Step 2: System of Equations. Analysis of Dynamics:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-3-angle-and-phase-space-simulation","text":"The forced damped pendulum model is relevant to various engineering and physical systems. Some real-world examples include: Energy harvesting systems , where mechanical vibrations are converted into electrical energy using oscillating parts. Suspension bridges , where damping and periodic forces play a role in stabilizing the structure under wind or traffic loads. Oscillating electrical circuits (e.g., RLC circuits), which behave analogously to mechanical oscillators with damping and driving forces. Biomechanics , such as modeling the motion of limbs or joints under muscle activation and external load.","title":"Step 3: Angle and Phase Space Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-4-poincare-section","text":"Python Code: Combined Pendulum Plots (\u03b8(t), \u03c9(t), Phase Portrait) python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 L = 1.0 b = 0.3 A = 1.2 w = 2.0 # Initial conditions theta0 = 0.2 omega0 = 0.0 y0 = [theta0, omega0] # Time setup t_start = 0 t_end = 20 num_points = 5000 t_vals = np.linspace(t_start, t_end, num_points) # Define the system def pendulum(t, y): theta = y[0] omega = y[1] dtheta_dt = omega domega_dt = -b * omega - (g / L) * np.sin(theta) + A * np.cos(w * t) return [dtheta_dt, domega_dt] # Solve the system sol = solve_ivp(pendulum, [t_start, t_end], y0, t_eval=t_vals) theta = sol.y[0] omega = sol.y[1] time = sol.t # Plot results in subplots fig, axs = plt.subplots(2, 2, figsize=(12, 8)) fig.suptitle('Forced Damped Pendulum Simulation', fontsize=16) # \u03b8(t) axs[0, 0].plot(time, theta, label='\u03b8(t)', color='royalblue') axs[0, 0].set_title('Angle vs Time') axs[0, 0].set_xlabel('Time (s)') axs[0, 0].set_ylabel('Angle \u03b8 (rad)') axs[0, 0].grid(True) axs[0, 0].legend() # \u03c9(t) axs[0, 1].plot(time, omega, label='d\u03b8/dt(t)', color='orange') axs[0, 1].set_title('Angular Velocity vs Time') axs[0, 1].set_xlabel('Time (s)') axs[0, 1].set_ylabel('Angular Velocity (rad/s)') axs[0, 1].grid(True) axs[0, 1].legend() # Phase portrait: \u03c9 vs \u03b8 axs[1, 0].plot(theta, omega, label='Phase Portrait', color='steelblue') axs[1, 0].set_title('Phase Portrait') axs[1, 0].set_xlabel('Angle \u03b8 (rad)') axs[1, 0].set_ylabel('Angular Velocity d\u03b8/dt (rad/s)') axs[1, 0].grid(True) axs[1, 0].legend() # Hide unused subplot axs[1, 1].axis('off') plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.show()","title":"Step 4: Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation-of-the-code","text":"Parameters : The script defines physical parameters including \\(g\\) (gravity), \\(L\\) (length), \\(b\\) (damping), \\(A\\) (amplitude of forcing), and \\(\\omega\\) (driving frequency). ODE System : The nonlinear second-order differential equation is rewritten as a system of first-order ODEs: $$ \\frac{d\\theta}{dt} = \\omega, \\quad \\frac{d\\omega}{dt} = -b\\omega - \\frac{g}{L} \\sin\\theta + A \\cos(\\omega t) $$ Numerical Solution : The system is solved using solve_ivp from scipy.integrate , which implements a Runge-Kutta method with adaptive time stepping. Plots : \\(\\theta(t)\\) \u2014 Angle over time \\(\\dot{\\theta}(t)\\) \u2014 Angular velocity over time Phase portrait \u2014 \\(\\dot{\\theta}\\) vs. \\(\\theta\\)","title":"Explanation of the Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Step 1: Deriving Kepler's Third Law from Newtonian Mechanics Let us consider a body of mass \\(m\\) in a circular orbit of radius \\(r\\) around a much larger mass \\(M\\) (e.g., a planet orbiting the Sun). Newton\u2019s Law of Gravitation provides the gravitational force between them: \\[F_g = \\frac{G M m}{r^2}\\] The required centripetal force to maintain a circular orbit is: \\[F_c = m \\frac{v^2}{r}\\] Equating the two forces: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r}\\] Canceling \\(m\\) and simplifying: \\[v^2 = \\frac{G M}{r}\\] The orbital speed \\(v\\) is related to the orbital period \\(T\\) by: \\[v = \\frac{2\\pi r}{T}\\] Substitute into the previous equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r}\\] Now solve for \\(T^2\\) : \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r}\\] Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : \\[T^2 = \\frac{4\\pi^2}{G M} r^3\\] This is Kepler\u2019s Third Law , showing that: \\[T^2 \\propto r^3\\] The constant of proportionality depends only on the central mass \\(M\\) and physical constant \\(G\\) : \\[\\frac{T^2}{r^3} = \\frac{4\\pi^2}{G M}\\] Step 2: Implications for Planetary Motions Kepler\u2019s Third Law has deep implications for understanding planetary systems: Uniformity Across Planets : For planets orbiting the same body (like the Sun), the ratio \\(T^2/r^3\\) is constant. This means that we can compare orbits across the solar system using only period and radius. Example : If one planet is 2 times farther from the Sun than another, its period will be: \\[T = T_0 \\cdot \\left(\\frac{2r_0}{r_0}\\right)^{3/2} = T_0 \\cdot 2^{3/2} \\approx 2.828 \\cdot T_0\\] Role of Mass : The mass of the orbiting object \\(m\\) cancels in the derivation. So small satellites and large moons follow the same law, depending only on the central mass \\(M\\) . Applications : Calculating planetary distances Estimating stellar and planetary masses Predicting satellite orbits Step 3: Real-World Example \u2013 The Moon Let\u2019s use Kepler\u2019s law to estimate Earth\u2019s mass from the Moon\u2019s orbit: Orbital radius of Moon: \\(r = 3.84 \\times 10^8\\) m Period: \\(T = 27.32\\) days = \\(2.36 \\times 10^6\\) s Rearranging the law: \\[M = \\frac{4\\pi^2 r^3}{G T^2}\\] Plugging in values: \\[M = \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} (2.36 \\times 10^6)^2}\\] This yields approximately \\(M \\approx 5.97 \\times 10^{24}\\) kg \u2014 a very accurate estimate of Earth's mass. This confirms both the validity and the precision of Kepler\u2019s Third Law. Step 4: Python Simulation \u2013 Visualizing \\(T^2 \\propto r^3\\) We can simulate various orbital radii and plot \\(T^2\\) vs \\(r^3\\) to confirm the linear relationship: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Orbital radii (m) radii = np.linspace(7e6, 4.2e7, 100) # from 7000 km to 42,000 km periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # T = 2\u03c0\u221a(r^3/GM) # Plotting T^2 vs r^3 r3 = radii**3 T2 = periods**2 plt.figure(figsize=(8, 6)) plt.plot(r3, T2, color='navy') plt.xlabel('$r^3$ (m$^3$)') plt.ylabel('$T^2$ (s$^2$)') plt.title('Kepler\\'s Third Law: $T^2$ vs $r^3$') plt.grid(True) plt.tight_layout() plt.show() Step 6: Elliptical Orbits and Generalization For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] The law still holds for all planets and moons with elliptical paths, as long as \\(a\\) is used instead of \\(r\\) . Summary We derived and confirmed Kepler\u2019s Third Law for circular orbits. The law connects period and radius via gravity. Simulations and plots verify that \\(T^2 \\propto r^3\\) . Real-world systems (like the Moon or satellites) follow this same law.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-deriving-keplers-third-law-from-newtonian-mechanics","text":"Let us consider a body of mass \\(m\\) in a circular orbit of radius \\(r\\) around a much larger mass \\(M\\) (e.g., a planet orbiting the Sun). Newton\u2019s Law of Gravitation provides the gravitational force between them: \\[F_g = \\frac{G M m}{r^2}\\] The required centripetal force to maintain a circular orbit is: \\[F_c = m \\frac{v^2}{r}\\] Equating the two forces: \\[\\frac{G M m}{r^2} = m \\frac{v^2}{r}\\] Canceling \\(m\\) and simplifying: \\[v^2 = \\frac{G M}{r}\\] The orbital speed \\(v\\) is related to the orbital period \\(T\\) by: \\[v = \\frac{2\\pi r}{T}\\] Substitute into the previous equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{G M}{r}\\] Now solve for \\(T^2\\) : \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r}\\] Multiply both sides by \\(T^2\\) and divide by \\(G M\\) : \\[T^2 = \\frac{4\\pi^2}{G M} r^3\\] This is Kepler\u2019s Third Law , showing that: \\[T^2 \\propto r^3\\] The constant of proportionality depends only on the central mass \\(M\\) and physical constant \\(G\\) : \\[\\frac{T^2}{r^3} = \\frac{4\\pi^2}{G M}\\]","title":"Step 1: Deriving Kepler's Third Law from Newtonian Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-implications-for-planetary-motions","text":"Kepler\u2019s Third Law has deep implications for understanding planetary systems: Uniformity Across Planets : For planets orbiting the same body (like the Sun), the ratio \\(T^2/r^3\\) is constant. This means that we can compare orbits across the solar system using only period and radius. Example : If one planet is 2 times farther from the Sun than another, its period will be: \\[T = T_0 \\cdot \\left(\\frac{2r_0}{r_0}\\right)^{3/2} = T_0 \\cdot 2^{3/2} \\approx 2.828 \\cdot T_0\\] Role of Mass : The mass of the orbiting object \\(m\\) cancels in the derivation. So small satellites and large moons follow the same law, depending only on the central mass \\(M\\) . Applications : Calculating planetary distances Estimating stellar and planetary masses Predicting satellite orbits","title":"Step 2: Implications for Planetary Motions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-real-world-example-the-moon","text":"Let\u2019s use Kepler\u2019s law to estimate Earth\u2019s mass from the Moon\u2019s orbit: Orbital radius of Moon: \\(r = 3.84 \\times 10^8\\) m Period: \\(T = 27.32\\) days = \\(2.36 \\times 10^6\\) s Rearranging the law: \\[M = \\frac{4\\pi^2 r^3}{G T^2}\\] Plugging in values: \\[M = \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{6.674 \\times 10^{-11} (2.36 \\times 10^6)^2}\\] This yields approximately \\(M \\approx 5.97 \\times 10^{24}\\) kg \u2014 a very accurate estimate of Earth's mass. This confirms both the validity and the precision of Kepler\u2019s Third Law.","title":"Step 3: Real-World Example \u2013 The Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-4-python-simulation-visualizing-t2-propto-r3","text":"We can simulate various orbital radii and plot \\(T^2\\) vs \\(r^3\\) to confirm the linear relationship: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Orbital radii (m) radii = np.linspace(7e6, 4.2e7, 100) # from 7000 km to 42,000 km periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # T = 2\u03c0\u221a(r^3/GM) # Plotting T^2 vs r^3 r3 = radii**3 T2 = periods**2 plt.figure(figsize=(8, 6)) plt.plot(r3, T2, color='navy') plt.xlabel('$r^3$ (m$^3$)') plt.ylabel('$T^2$ (s$^2$)') plt.title('Kepler\\'s Third Law: $T^2$ vs $r^3$') plt.grid(True) plt.tight_layout() plt.show()","title":"Step 4: Python Simulation \u2013 Visualizing \\(T^2 \\propto r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-6-elliptical-orbits-and-generalization","text":"For elliptical orbits, \\(r\\) is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] The law still holds for all planets and moons with elliptical paths, as long as \\(a\\) is used instead of \\(r\\) .","title":"Step 6: Elliptical Orbits and Generalization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived and confirmed Kepler\u2019s Third Law for circular orbits. The law connects period and radius via gravity. Simulations and plots verify that \\(T^2 \\propto r^3\\) . Real-world systems (like the Moon or satellites) follow this same law.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Step 1: Define the First, Second, and Third Cosmic Velocities with Physical Meaning First Cosmic Velocity (Orbital Velocity) : This is the minimum speed required for an object to stay in a stable circular orbit near the surface of a celestial body. It occurs when the gravitational pull provides the exact centripetal force necessary to maintain that orbit: \\( \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) \\) Second Cosmic Velocity (Escape Velocity) : The second cosmic velocity represents the threshold speed to break free from a body's gravitational field entirely. It's derived from the conservation of energy, ensuring that an object's total mechanical energy reaches zero at an infinite distance: \\( \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) \\) Third Cosmic Velocity (Interstellar Escape Velocity) : To exit an entire star system (like the Solar System), an object must overcome not just Earth's gravity, but also the gravitational influence of the Sun. This velocity is more complex, as it involves both escape from the planet and additional speed to escape from heliocentric orbit. Step 2: Theoretical Derivation and Equations 2.1 First Cosmic Velocity: Set gravitational force equal to centripetal force: \\[\\frac{G M m}{R^2} = m \\frac{v^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{G M}{R}}\\] 2.2 Second Cosmic Velocity: Use energy conservation principle: \\[\\frac{1}{2}mv_2^2 = \\frac{G M m}{R} \\Rightarrow v_2 = \\sqrt{\\frac{2 G M}{R}}\\] 2.3 Third Cosmic Velocity \u2013 Escape from the Sun's Gravity The third cosmic velocity is defined as the speed required to escape the Sun's gravitational field starting from Earth\u2019s orbit. Unlike the second velocity, it considers the object already in motion due to Earth's orbital speed. We define: - \\(M_{\\text{Sun}}\\) : mass of the Sun - \\(r_{\\text{Earth-Sun}}\\) : average distance between the Earth and Sun (\u2248 1 AU) Escape Velocity from Sun at Earth's Orbit : \\[v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Earth's Orbital Speed Around the Sun : \\[v_{\\text{Earth}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Third Cosmic Velocity : To break free from the Solar System, the spacecraft must gain enough speed beyond what Earth already provides: \\[v_3 = v_{\\text{esc,Sun}} - v_{\\text{Earth}}\\] Substituting the expressions: \\[v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Factoring out the common term: \\[v_3 = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} (\\sqrt{2} - 1)\\] This shows that the third cosmic velocity is a fraction \\((\\sqrt{2} - 1 \\approx 0.414)\\) of the Sun\u2019s escape velocity at Earth's orbital distance. This simplification is useful for approximating interstellar mission speeds without requiring complex simulations. Step 3: Python Code to Compute and Plot the Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 # Planetary data: name, radius (m), mass (kg) bodies = { 'Earth': {'R': 6.371e6, 'M': 5.972e24}, 'Mars': {'R': 3.390e6, 'M': 6.417e23}, 'Jupiter': {'R': 6.9911e7, 'M': 1.898e27} } # Prepare results names = [] v1 = [] # Orbital velocity v2 = [] # Escape velocity for body, data in bodies.items(): R = data['R'] M = data['M'] names.append(body) v1.append(np.sqrt(G * M / R)) v2.append(np.sqrt(2 * G * M / R)) # Plotting x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1, width, label='First Cosmic Velocity $v_1$', color='skyblue') plt.bar(x + width/2, v2, width, label='Second Cosmic Velocity $v_2$', color='orange') plt.xticks(x, names) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Celestial Bodies') plt.legend() plt.grid(axis='y') plt.tight_layout() plt.show() 3. Applications in Space Exploration \\(v_1\\) \u2013 Used to place satellites into low Earth orbit (LEO), GPS, and communication satellites. \\(v_2\\) \u2013 Required for missions to the Moon, Mars, and beyond. \\(v_3\\) \u2013 Required to leave the Solar System; achieved by spacecraft like Voyager 1 and 2. First Cosmic Velocity : Essential for satellite missions. Near Earth\u2019s surface, \\(v_1 \\approx 7.9\\) km/s, but satellites in LEO (e.g., at 400 km altitude) orbit at slightly lower speeds (around 7.6 km/s). This velocity is targeted during launches like those delivering payloads to the ISS. Second Cosmic Velocity : Required for planetary escape. For Earth, \\(v_2 \\approx 11.2\\) km/s. Spacecraft such as those used in the Apollo missions had to exceed this threshold to reach the Moon. On Jupiter, escape velocity reaches 59.5 km/s, demanding enormous propulsion capacity (e.g., Juno mission). Third Cosmic Velocity : Enables interstellar escape. For Earth, \\(v_3 \\approx 16.7\\) km/s relative to the heliocentric frame. Voyager 1 gained this velocity through gravity assists and now travels ~17 km/s away from the Sun. These values influence fuel budgets, trajectory design, and feasibility of interstellar probes. Summary Derived and computed \\(v_1\\) , \\(v_2\\) , and discussed \\(v_3\\) Applied to Earth, Mars, and Jupiter Visualized their significance for space missions and satellite deployment","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-1-define-the-first-second-and-third-cosmic-velocities-with-physical-meaning","text":"First Cosmic Velocity (Orbital Velocity) : This is the minimum speed required for an object to stay in a stable circular orbit near the surface of a celestial body. It occurs when the gravitational pull provides the exact centripetal force necessary to maintain that orbit: \\( \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) \\) Second Cosmic Velocity (Escape Velocity) : The second cosmic velocity represents the threshold speed to break free from a body's gravitational field entirely. It's derived from the conservation of energy, ensuring that an object's total mechanical energy reaches zero at an infinite distance: \\( \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) \\) Third Cosmic Velocity (Interstellar Escape Velocity) : To exit an entire star system (like the Solar System), an object must overcome not just Earth's gravity, but also the gravitational influence of the Sun. This velocity is more complex, as it involves both escape from the planet and additional speed to escape from heliocentric orbit.","title":"Step 1: Define the First, Second, and Third Cosmic Velocities with Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-2-theoretical-derivation-and-equations","text":"","title":"Step 2: Theoretical Derivation and Equations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-first-cosmic-velocity","text":"Set gravitational force equal to centripetal force: \\[\\frac{G M m}{R^2} = m \\frac{v^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{G M}{R}}\\]","title":"2.1 First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-second-cosmic-velocity","text":"Use energy conservation principle: \\[\\frac{1}{2}mv_2^2 = \\frac{G M m}{R} \\Rightarrow v_2 = \\sqrt{\\frac{2 G M}{R}}\\]","title":"2.2 Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity-escape-from-the-suns-gravity","text":"The third cosmic velocity is defined as the speed required to escape the Sun's gravitational field starting from Earth\u2019s orbit. Unlike the second velocity, it considers the object already in motion due to Earth's orbital speed. We define: - \\(M_{\\text{Sun}}\\) : mass of the Sun - \\(r_{\\text{Earth-Sun}}\\) : average distance between the Earth and Sun (\u2248 1 AU) Escape Velocity from Sun at Earth's Orbit : \\[v_{\\text{esc,Sun}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Earth's Orbital Speed Around the Sun : \\[v_{\\text{Earth}} = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Third Cosmic Velocity : To break free from the Solar System, the spacecraft must gain enough speed beyond what Earth already provides: \\[v_3 = v_{\\text{esc,Sun}} - v_{\\text{Earth}}\\] Substituting the expressions: \\[v_3 = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}}\\] Factoring out the common term: \\[v_3 = \\sqrt{\\frac{G M_{\\text{Sun}}}{r_{\\text{Earth-Sun}}}} (\\sqrt{2} - 1)\\] This shows that the third cosmic velocity is a fraction \\((\\sqrt{2} - 1 \\approx 0.414)\\) of the Sun\u2019s escape velocity at Earth's orbital distance. This simplification is useful for approximating interstellar mission speeds without requiring complex simulations.","title":"2.3 Third Cosmic Velocity \u2013 Escape from the Sun's Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-3-python-code-to-compute-and-plot-the-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant in m^3 kg^-1 s^-2 # Planetary data: name, radius (m), mass (kg) bodies = { 'Earth': {'R': 6.371e6, 'M': 5.972e24}, 'Mars': {'R': 3.390e6, 'M': 6.417e23}, 'Jupiter': {'R': 6.9911e7, 'M': 1.898e27} } # Prepare results names = [] v1 = [] # Orbital velocity v2 = [] # Escape velocity for body, data in bodies.items(): R = data['R'] M = data['M'] names.append(body) v1.append(np.sqrt(G * M / R)) v2.append(np.sqrt(2 * G * M / R)) # Plotting x = np.arange(len(names)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1, width, label='First Cosmic Velocity $v_1$', color='skyblue') plt.bar(x + width/2, v2, width, label='Second Cosmic Velocity $v_2$', color='orange') plt.xticks(x, names) plt.ylabel('Velocity (m/s)') plt.title('Cosmic Velocities for Celestial Bodies') plt.legend() plt.grid(axis='y') plt.tight_layout() plt.show()","title":"Step 3: Python Code to Compute and Plot the Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-applications-in-space-exploration","text":"\\(v_1\\) \u2013 Used to place satellites into low Earth orbit (LEO), GPS, and communication satellites. \\(v_2\\) \u2013 Required for missions to the Moon, Mars, and beyond. \\(v_3\\) \u2013 Required to leave the Solar System; achieved by spacecraft like Voyager 1 and 2. First Cosmic Velocity : Essential for satellite missions. Near Earth\u2019s surface, \\(v_1 \\approx 7.9\\) km/s, but satellites in LEO (e.g., at 400 km altitude) orbit at slightly lower speeds (around 7.6 km/s). This velocity is targeted during launches like those delivering payloads to the ISS. Second Cosmic Velocity : Required for planetary escape. For Earth, \\(v_2 \\approx 11.2\\) km/s. Spacecraft such as those used in the Apollo missions had to exceed this threshold to reach the Moon. On Jupiter, escape velocity reaches 59.5 km/s, demanding enormous propulsion capacity (e.g., Juno mission). Third Cosmic Velocity : Enables interstellar escape. For Earth, \\(v_3 \\approx 16.7\\) km/s relative to the heliocentric frame. Voyager 1 gained this velocity through gravity assists and now travels ~17 km/s away from the Sun. These values influence fuel budgets, trajectory design, and feasibility of interstellar probes.","title":"3. Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"Derived and computed \\(v_1\\) , \\(v_2\\) , and discussed \\(v_3\\) Applied to Earth, Mars, and Jupiter Visualized their significance for space missions and satellite deployment","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Step 1: Analyze Possible Trajectories When a payload is released from a rocket near Earth, its future motion is determined by its speed, direction, and altitude. Depending on the specific energy \\(\\epsilon\\) of the system, the resulting path can be classified as: Elliptical Trajectory ( \\(\\epsilon < 0\\) ): Bound orbit, repeating paths (circular or oval). Parabolic Trajectory ( \\(\\epsilon = 0\\) ): The minimum speed needed to escape Earth \u2014 marginal case. Hyperbolic Trajectory ( \\(\\epsilon > 0\\) ): Payload escapes Earth with excess kinetic energy. The specific mechanical energy (energy per unit mass) is: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] Where: - \\(v\\) is the speed of the payload, - \\(r\\) is the radial distance from Earth\u2019s center, - \\(G\\) is the gravitational constant, - \\(M\\) is the Earth's mass. The expression comes from combining kinetic and gravitational potential energy: Kinetic energy per unit mass: \\(\\frac{1}{2}v^2\\) Gravitational potential energy per unit mass: \\(-\\frac{GM}{r}\\) Hence: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] This confirms: - \\(\\epsilon < 0\\) : Elliptical orbit (bound) - \\(\\epsilon = 0\\) : Parabolic escape - \\(\\epsilon > 0\\) : Hyperbolic escape Formulas for Orbital Mechanics Escape Velocity The speed required to escape a celestial body's gravity from a distance \\(r\\) : \\[v_{esc} = \\sqrt{\\frac{2GM}{r}}\\] Circular Orbital Velocity The speed needed to maintain a circular orbit at radius \\(r\\) : \\[v_{circ} = \\sqrt{\\frac{GM}{r}}\\] Specific Mechanical Energy The total energy per unit mass (kinetic + potential): \\[E = \\frac{v^2}{2} - \\frac{GM}{r}\\] \\(E < 0\\) : Bound orbit (elliptical) \\(E = 0\\) : Parabolic escape \\(E > 0\\) : Hyperbolic escape Gravitational Force Between Two Masses \\[F = \\frac{G m_1 m_2}{r^2}\\] Orbital Period (Kepler\u2019s Third Law) Applies to circular orbits: \\( \\(T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\) \\) Step 2: Equations of Motion in 2D From Newton\u2019s Law of Gravitation: \\[ \\frac{d^2\\vec{r}}{dt^2} = -\\frac{GM}{r^3}\\vec{r} \\] Let \\(\\vec{r} = (x, y)\\) , then: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{r^3}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{r^3} \\] To solve numerically, define the state vector \\([x, y, v_x, v_y]\\) with: \\[ \\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y $$ $$ \\frac{dv_x}{dt} = -\\frac{GMx}{r^3}, \\quad \\frac{dv_y}{dt} = -\\frac{GMy}{r^3} \\] Step 3: Python Code for Trajectory Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # mass of Earth [kg] R = 6.371e6 # radius of Earth [m] mu = G * M # gravitational parameter [m^3/s^2] # Define system of ODEs def dynamics(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Initial position: 400 km above Earth's surface x0 = R + 400000 # meters y0 = 0 # Initial velocities for different trajectory types v_values = [7300, 11180, 13000] # m/s: elliptical, parabolic, hyperbolic labels = ['Elliptical', 'Parabolic', 'Hyperbolic'] colors = ['blue', 'green', 'red'] plt.figure(figsize=(8, 8)) for v0, label, color in zip(v_values, labels, colors): vx0 = 0 vy0 = v0 state0 = [x0, y0, vx0, vy0] t_span = (0, 8000) t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(dynamics, t_span, state0, t_eval=t_eval, rtol=1e-9) x, y = sol.y[0], sol.y[1] plt.plot(x/1000, y/1000, label=label, color=color) # Earth theta = np.linspace(0, 2*np.pi, 300) plt.plot((R * np.cos(theta))/1000, (R * np.sin(theta))/1000, 'k', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Trajectories of a Payload Released Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Step 4: Interpretation Elliptical : Captured orbit. Occurs when the initial speed is below escape velocity. Parabolic : Boundary case. Object escapes with zero final velocity. Hyperbolic : Object escapes with excess energy. Relevant for deep space missions. These simulations reflect practical use cases in satellite deployment, space debris behavior, and interplanetary travel. Summary Introduced energy-based classification of orbits. Derived motion equations for gravitational acceleration in 2D. Created a realistic simulation tool in Python to explore various escape conditions. Discussed relevance to orbital insertion and mission planning.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-1-analyze-possible-trajectories","text":"When a payload is released from a rocket near Earth, its future motion is determined by its speed, direction, and altitude. Depending on the specific energy \\(\\epsilon\\) of the system, the resulting path can be classified as: Elliptical Trajectory ( \\(\\epsilon < 0\\) ): Bound orbit, repeating paths (circular or oval). Parabolic Trajectory ( \\(\\epsilon = 0\\) ): The minimum speed needed to escape Earth \u2014 marginal case. Hyperbolic Trajectory ( \\(\\epsilon > 0\\) ): Payload escapes Earth with excess kinetic energy. The specific mechanical energy (energy per unit mass) is: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] Where: - \\(v\\) is the speed of the payload, - \\(r\\) is the radial distance from Earth\u2019s center, - \\(G\\) is the gravitational constant, - \\(M\\) is the Earth's mass. The expression comes from combining kinetic and gravitational potential energy: Kinetic energy per unit mass: \\(\\frac{1}{2}v^2\\) Gravitational potential energy per unit mass: \\(-\\frac{GM}{r}\\) Hence: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] This confirms: - \\(\\epsilon < 0\\) : Elliptical orbit (bound) - \\(\\epsilon = 0\\) : Parabolic escape - \\(\\epsilon > 0\\) : Hyperbolic escape","title":"Step 1: Analyze Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#formulas-for-orbital-mechanics","text":"Escape Velocity The speed required to escape a celestial body's gravity from a distance \\(r\\) : \\[v_{esc} = \\sqrt{\\frac{2GM}{r}}\\] Circular Orbital Velocity The speed needed to maintain a circular orbit at radius \\(r\\) : \\[v_{circ} = \\sqrt{\\frac{GM}{r}}\\] Specific Mechanical Energy The total energy per unit mass (kinetic + potential): \\[E = \\frac{v^2}{2} - \\frac{GM}{r}\\] \\(E < 0\\) : Bound orbit (elliptical) \\(E = 0\\) : Parabolic escape \\(E > 0\\) : Hyperbolic escape Gravitational Force Between Two Masses \\[F = \\frac{G m_1 m_2}{r^2}\\] Orbital Period (Kepler\u2019s Third Law) Applies to circular orbits:","title":"Formulas for Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#t-2pi-sqrtfracr3gm","text":"","title":"\\(\\(T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\)\\)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-2-equations-of-motion-in-2d","text":"From Newton\u2019s Law of Gravitation: \\[ \\frac{d^2\\vec{r}}{dt^2} = -\\frac{GM}{r^3}\\vec{r} \\] Let \\(\\vec{r} = (x, y)\\) , then: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{r^3}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{r^3} \\] To solve numerically, define the state vector \\([x, y, v_x, v_y]\\) with: \\[ \\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y $$ $$ \\frac{dv_x}{dt} = -\\frac{GMx}{r^3}, \\quad \\frac{dv_y}{dt} = -\\frac{GMy}{r^3} \\]","title":"Step 2: Equations of Motion in 2D"},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-3-python-code-for-trajectory-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # mass of Earth [kg] R = 6.371e6 # radius of Earth [m] mu = G * M # gravitational parameter [m^3/s^2] # Define system of ODEs def dynamics(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -mu * x / r**3 ay = -mu * y / r**3 return [vx, vy, ax, ay] # Initial position: 400 km above Earth's surface x0 = R + 400000 # meters y0 = 0 # Initial velocities for different trajectory types v_values = [7300, 11180, 13000] # m/s: elliptical, parabolic, hyperbolic labels = ['Elliptical', 'Parabolic', 'Hyperbolic'] colors = ['blue', 'green', 'red'] plt.figure(figsize=(8, 8)) for v0, label, color in zip(v_values, labels, colors): vx0 = 0 vy0 = v0 state0 = [x0, y0, vx0, vy0] t_span = (0, 8000) t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(dynamics, t_span, state0, t_eval=t_eval, rtol=1e-9) x, y = sol.y[0], sol.y[1] plt.plot(x/1000, y/1000, label=label, color=color) # Earth theta = np.linspace(0, 2*np.pi, 300) plt.plot((R * np.cos(theta))/1000, (R * np.sin(theta))/1000, 'k', label='Earth') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Trajectories of a Payload Released Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Step 3: Python Code for Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#step-4-interpretation","text":"Elliptical : Captured orbit. Occurs when the initial speed is below escape velocity. Parabolic : Boundary case. Object escapes with zero final velocity. Hyperbolic : Object escapes with excess energy. Relevant for deep space missions. These simulations reflect practical use cases in satellite deployment, space debris behavior, and interplanetary travel.","title":"Step 4: Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"Introduced energy-based classification of orbits. Derived motion equations for gravitational acceleration in 2D. Created a realistic simulation tool in Python to explore various escape conditions. Discussed relevance to orbital insertion and mission planning.","title":"Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}